@startmindmap

* 实现领域驱动设计
** 背景
*** 设计不只是感观,设计就是产品的工作方式。 --Steve Jobs
*** 为什么需要DDD？
**** DDD的好处
***** 软件开发的最大问题之一便是业务人员和技术人员需要某种翻译才能交流。DDD将业务人员和技术人员放在同一个层面上。
** 目的
*** 创造一个可测试的、可伸缩的、组织良好的软件模型。
** 内容
*** 挑战
**** TODO
*** 概念
**** 战略、战术设计
***** 战略设计： 组织和分割复杂领域，包含领域、限界上下文和上下文映射图
***** 战术设计： 实现领域模型，包含实体、值对象、领域服务、领域事件、模块、聚合、工厂、资源库、集成限界上下文和应用程序
**** 战略设计基础： 领域、子域和限界上下文
***** 领域
****** 一个组织所做的事情以及其中所包含的一切
****** 一个领域被分为若干子域，领域模型在限界上下文中完成开发
****** 在开发一个领域模型时，我们关注的通常只是这个业务系统的某个方面
***** 子域
****** 核心域： 业务成功的主要促成因素
****** 支撑子域： 限界上下文对应着业务的某些重要方面，但却不是核心。创建支撑子域的原因在于它们专注于业务的某个方面。
****** 通用子域： 被用于整个业务系统的子域。
***** 限界上下文
****** 上下文命名方式： 模型名+上下文。比如协作上下文、身份与访问上下文
****** 同一事物，在不同阶段可能拥有不同概念，比如图书出版前中后阶段，图书定义不同，所以其各自拥有限界上下文
***** 问题空间、解决方案空间
****** 问题空间： 划分子域
****** 解决方案空间： 划分限界上下文
***** 常见问题
****** 贫血模型： 业务逻辑不包含任何业务行为，数据与业务行为不一致
****** 大泥球： 没有清晰边界，耦合严重，依赖关系混乱
****** 谷仓效应： 同一模型在不同上下文中各自建模，相似但不一致，难以复用和对齐
***** case
****** <img:./image/2026-01-06-19-13-20.png{scale=0.3}>
****** <img:./image/2026-01-06-19-18-58.png{scale=0.3}>
****** <img:./image/2026-01-06-19-19-45.png{scale=0.3}>
****** <img:./image/2026-01-06-19-40-04.png{scale=0.3}>
**** 上下文映射图
***** 组织、集成模式
****** 合作伙伴： 建立合作关系，共同开发和维护模型
****** 客户方-供应方开发： 上下游团队合作，上游团队为下游团队提供服务
****** 共享内核： 多个团队共享一部分模型
****** 遵奉者： 上游没有时间迭代模型，下游团队只能遵循
****** 防腐层ACL： 上游模型不符合下游需求，下游建立防腐层进行翻译转换
****** 开放主机服务OHS： 下游有新的模型要求，上游提供不同API供不同下游调用
****** 发布语言PL： 发布一套通用语言（如pb）供不同上下文使用，常与开放主机服务结合使用
****** 另谋他路： 与目标上下文没有集成需求，换个方式实现目标功能
****** 大泥球： 划定边界，将边界模糊的模型放在一起，避免影响其他模型
***** case
****** <img:./image/2026-01-06-19-50-28.png{scale=0.3}>
****** <img:./image/2026-01-06-20-39-32.png{scale=0.3}>
****** <img:./image/2026-01-06-20-51-47.png{scale=0.3}>
****** <img:./image/2026-01-06-20-56-53.png{scale=0.3}>
**** 架构
***** 分层架构： 严格分层架构中，某一层只能调用其下层；松散分层架构中，允许跨层调用。由于UI层和应用层往往都会调用基础设施层，所以大多数系统都是松散分层架构
****** <img:./image/2026-01-15-08-27-59.png{scale=0.3}>
****** <img:./image/2026-01-15-09-16-02.png{scale=0.3}>
***** 六边形架构： 外六边形对应不同端口，内六边形对应应用核心（用例），端口通过适配器与核心交互
****** <img:./image/2026-01-15-09-24-58.png{scale=0.3}>
***** 面向服务架构SOA： 将应用划分为多个服务，每个服务对应一个业务功能。在DDD中，每⼀个领域模型由⼀组SOA开放服务所包围，这些服务是满⾜业务⽬标的。
****** <img:./image/2026-01-16-09-12-16.png{scale=0.3}>
***** RESTful HTTP： 基于资源的架构风格，通过HTTP协议进行通信，使用统一的URI标识资源，使用HTTP方法（GET、POST、PUT、DELETE等）进行操作。
****** 在DDD中，如果将领域模型直接暴露为RESTful资源，会使系统接口变得脆弱，任何修改都可能导致不可用，所以应该为系统接口层单独创建一个限界上下文，在此上下文中通过适当的策略来访问实际的领域模型。
***** 数据网织： 本质是将分散在不同限界上下文、聚合根中的数据，按照领域语义进行关联、整合和按需组装，避免数据孤岛，同时保持领域模型的纯度。
***** 事件驱动架构： 通过事件总线实现不同组件之间的解耦通信，适用于高并发和分布式系统
****** <img:./image/2026-01-19-20-08-09.png{scale=0.3}>
***** CQRS架构模式： 将读写操作分离，读操作使用专门的查询模型，写操作使用命令模型
****** <img:./image/2026-01-19-19-10-26.png{scale=0.3}>
***** case
**** 实体
***** 用于区分不同对象的身份标识，具有唯一性，带有属性和行为。
***** 唯一标识可存放于值对象中，生成方式可以是内存生成(带领域名称、时间信息、UUID)、数据库自增ID等。在持久化前生成的话，在内存中具有稳定的身份id，领域对象可直接使用
***** 领域标识： 同unique key
***** 委派标识： 同primary key
***** 意图展现接口： 准确体现动作，往往不需要传入参数，直接实现意图，比如active()、deactivate()等
***** 自封装： 通过方法封装属性的修改，避免外部直接修改属性，保证对象的一致性
***** 契约式设计： 通过前置条件、后置条件、不变式等保证对象状态的一致性，提高可验证性
***** 常见问题
****** 对象分裂症： 委派对象不知道被委派对象的身份标识，导致无法识别委派对象
***** case
****** <img:./image/2026-01-07-08-50-23.png{scale=0.3}>
****** <img:./image/2026-01-07-09-06-19.png{scale=0.3}>
****** <img:./image/2026-01-07-09-10-22.png{scale=0.3}>
****** <img:./image/2026-01-07-13-18-16.png{scale=0.3}>
****** 为什么要避免大范围使用实体？
**** 值对象
***** 用于度量和描述事物，通常是不可变的，没有唯一标识。
***** 值对象特征： 不可变性、概念整体、可替换性、相等性、无副作用行为
***** 整体值对象模式： 将多个值对象组合成一个不可变的整体，比如金额和货币组成价格
***** 无副作用函数： 对某个对象操作，只产生输出，不会修改对象的状态。这也是函数式编程的核心思想
***** 标准类型： 可通过枚举、状态模式等实现
***** 状态模式： 用于表示对象的不同状态，通常通过类继承或组合实现
***** 自委派性：  自身职责范围内的行为自己完成（比如赋值、校验、计算），不依赖外部对象
***** 测试关注点： 关注值对象的创建、相等性、不可变性和行为，重点关注不变性
***** 展现模型： 用于解耦UI逻辑与领域逻辑，将视图的状态和行为封装在一个单独的模型对象中，提供给UI渲染
***** 层超类型（Layer Supertype）： 为某一层（如持久化、业务层、领域层）中所有类提供通用属性和行为，一般以抽象类的形式存在，作为复用载体。不对应具体业务对象，仅封装层内通用逻辑
***** 数据建模是次要的： 值对象的设计应优先考虑领域概念，而非数据存储需求
***** 常见问题
****** 欺骗模型： 使用语言自带的基本类型（如字符串、数字）来表示值对象，导致无法表达领域概念
****** O/R阻抗失配： 在面向对象（OO）和关系型数据库（RDBMS）进行持久化时，值对象在内存中和在持久化存储中的表示不一致，导致转换复杂
****** 建模泄漏： 领域模型因边界失守，封装失效，导致值对象被当作实体使用
***** case
****** 建模应该使用实体还是值对象？
******* 用值对象建模，有助于创建、测试、使用、优化和维护
****** <img:./image/2026-01-08-09-00-54.png{scale=0.3}>
**** 领域服务
***** 用于表示不适合放在实体或值对象中的业务逻辑，通常是无状态的，能够明确地表明限界上下文中的通用语言。
***** 常见问题
****** 贫血领域模型： 将所有业务逻辑放在领域服务中，导致实体和值对象缺乏行为
**** 领域事件
***** 命名方式： 名词+动词组合
***** 消费方式： 要考虑最终一致性，不能只由远程系统消费，也可以由本地系统消费
***** 订阅方： 通常在应用服务层或者领域服务层完成注册。
***** 事件处理器： 需要注意聚合的一大原则，在一个事务中，只对一个聚合进行修改，避免在事件通知过程中修改了另一个聚合实例
***** 幂等操作： 多次重复操作和一次操作的效果相同，避免重复消费事件导致数据不一致
**** 模块
***** 讲类放在不同模块中，以达到松耦合性和高内聚性。
***** 如何保障不同对象之间只存在有限耦合？
***** 设计原则
****** <img:./image/2026-01-26-09-22-05.png{scale=0.3}>
**** 聚合
***** 将相关对象组合成一个一致性边界，以保证数据的一致性和完整性。
***** 原则
****** 在一个事务中只修改一个聚合实例
****** 设计小聚合
***** 不同小规模对象集群如何聚合，以实现创建一致性边界？
**** 工厂
***** 多租户环境是什么？可能会存在什么问题？
**** 资源库
***** 一个安全的存储区域，用于存储和检索聚合根对象。
***** 和数据库的区别是什么？
**** 集成限界上下文
***** 如何通过上下文映射图集成不同模型？
**** 应用程序
***** 客户应该如何使用模型？
**** 其他
***** 什么是对象-关系阻抗失配？
*** 实践
**** 如何在项目中应用DDD
**** 如何做模型分离

@endmindmap
