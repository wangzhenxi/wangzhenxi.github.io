import{_ as i,o as a,c as e,af as r}from"./chunks/framework.R7EdO4cN.js";const t="/assets/image.Oz9GcTIW.png",o="/assets/image-1.CTt9MRFL.png",h="/assets/image-2.CszdVjWE.png",u="/assets/image-3.DJT5iSa_.png",n="/assets/image-4.mFIzsf0u.png",s="/assets/image-5.DGF7Tl-Z.png",d="/assets/image-6.Dv2F9IrO.png",c="/assets/image-7.5dZZNb7k.png",p="/assets/image-8.CbkTvWVB.png",b="/assets/image-9.CmKAAauq.png",q="/assets/image-10.CimGMSrg.png",m="/assets/2024-12-27-08-56-08.Bq2RJcvw.png",P="/assets/2025-01-06-09-20-54.CLIZdONy.png",f="/assets/2025-01-06-09-21-07.BqqjImCQ.png",k="/assets/2025-01-07-08-52-05.DVwlsp4Z.png",x="/assets/2025-01-21-09-06-16.Bz_rky5D.png",g="/assets/2025-02-10-09-05-01.DjdjFYEL.png",B=JSON.parse('{"title":"从零开始学架构","description":"","frontmatter":{"title":"从零开始学架构"},"headers":[],"relativePath":"notes/cong-ling-kai-shi-xue-jia-gou/index.md","filePath":"notes/cong-ling-kai-shi-xue-jia-gou/index.md"}'),S={name:"notes/cong-ling-kai-shi-xue-jia-gou/index.md"};function _(C,l,A,D,R,O){return a(),e("div",null,[...l[0]||(l[0]=[r('<h1 id="从零开始学架构" tabindex="-1">从零开始学架构 <a class="header-anchor" href="#从零开始学架构" aria-label="Permalink to &quot;从零开始学架构&quot;">​</a></h1><h2 id="第一章-概念和基础" tabindex="-1">第一章 概念和基础 <a class="header-anchor" href="#第一章-概念和基础" aria-label="Permalink to &quot;第一章 概念和基础&quot;">​</a></h2><h3 id="软件架构是什么" tabindex="-1">软件架构是什么？ <a class="header-anchor" href="#软件架构是什么" aria-label="Permalink to &quot;软件架构是什么？&quot;">​</a></h3><p>软件架构是指软件系统的顶层结构，而架构设计的目的是为了解决软件复杂度。</p><ul><li>避免为了高指标而做架构设计，有时候并不需要架构设计，会造成更高的项目成本</li><li>机器语言、汇编语言、高级语言的演进，解决了编码复杂度</li></ul><h4 id="系统架构的结构该如何拆解" tabindex="-1">系统架构的结构该如何拆解？ <a class="header-anchor" href="#系统架构的结构该如何拆解" aria-label="Permalink to &quot;系统架构的结构该如何拆解？&quot;">​</a></h4><p>可基于以下维度拆解：</p><ul><li>系统、子系统： 由一群有关联的个体所组成，根据某种规则运作。</li><li>模块、组件： 从逻辑角度拆分得到的单元是模块，负责职责分离；从物理角度拆分得到的单元是组件，负责单元复用，独立可替换。</li><li>框架、架构： 框架提供组件的规范；架构提供系统的结构。</li></ul><h3 id="架构设计的复杂度来源于什么" tabindex="-1">架构设计的复杂度来源于什么？ <a class="header-anchor" href="#架构设计的复杂度来源于什么" aria-label="Permalink to &quot;架构设计的复杂度来源于什么？&quot;">​</a></h3><ul><li>高性能，理论上会存在上限，优化只能逼近该上限，有以下手段： <ul><li>单进程 -&gt; 多进程</li><li>单线程 -&gt; 多线程</li><li>单机 -&gt; 多机</li><li>单任务 -&gt; 多任务</li></ul></li><li>高可用： <ul><li>机器冗余，包含连接管理，分配算法（n主n备）</li><li>存储高可用（一致性、可用性、分区容错性最多满足两个）</li><li>状态决策： 独裁式（单点监测）、协商式（监测&amp;投票）、民主式（去中心化）</li></ul></li><li>可拓展，可通过面向对象、设计模式解决： <ul><li>预测变化： 预测可能错误，不能每个设计点都考虑可拓展性</li><li>应对变化： <ul><li>方法一： 基本架构拆分变化层和稳定层</li><li>方法二： 提炼出抽象层和实现层，抽象层保持稳定，实现层支持定制开发</li></ul></li></ul></li><li>低成本 <ul><li>和高性能、高可用冲突，所以属于架构设计的附加约束</li><li>往往通过新技术引入实现</li></ul></li><li>安全性： <ul><li>功能安全、架构安全</li></ul></li></ul><h2 id="第二章-架构设计原则" tabindex="-1">第二章 架构设计原则 <a class="header-anchor" href="#第二章-架构设计原则" aria-label="Permalink to &quot;第二章 架构设计原则&quot;">​</a></h2><h3 id="架构设计三原则是什么" tabindex="-1">架构设计三原则是什么？ <a class="header-anchor" href="#架构设计三原则是什么" aria-label="Permalink to &quot;架构设计三原则是什么？&quot;">​</a></h3><ul><li>合适原则： 合适由于业界领先</li><li>简单原则： 简单优于复杂</li><li>演化原则： 演化优于一步到位</li></ul><h4 id="合适原则" tabindex="-1">合适原则 <a class="header-anchor" href="#合适原则" aria-label="Permalink to &quot;合适原则&quot;">​</a></h4><p>结合当前人力、条件、业务等约束，将资源整合发挥最大功效，快速落地，而不是生搬硬套。</p><p>常见问题：</p><ul><li>没有那么多人，却想干那么多活</li><li>没有那么多卓越的业务场景积累，却想创造业界领先方案</li></ul><h4 id="简单原则" tabindex="-1">简单原则 <a class="header-anchor" href="#简单原则" aria-label="Permalink to &quot;简单原则&quot;">​</a></h4><p>简单优于复杂。</p><ul><li>结构复杂性： 当组成的组件越多，组件的稳定性会直接影响系统的稳定性</li><li>逻辑复杂性： 逻辑杂糅在一个组件里，改动影响范围大</li></ul><h4 id="演化原则" tabindex="-1">演化原则 <a class="header-anchor" href="#演化原则" aria-label="Permalink to &quot;演化原则&quot;">​</a></h4><p>架构应满足当下业务需要，随着业务变化而变化</p><ul><li>设计过程中，保留优秀设计，修复缺陷设计，去掉无用设计</li><li>业务变化时，架构要拓展、重构、甚至重写</li><li>避免生搬硬套大公司做法，要根据自身业务特点，逐步演化</li></ul><h2 id="第三章-架构设计流程" tabindex="-1">第三章 架构设计流程 <a class="header-anchor" href="#第三章-架构设计流程" aria-label="Permalink to &quot;第三章 架构设计流程&quot;">​</a></h2><ul><li>识别复杂度： 罗列复杂度问题，优先级排序处理</li><li>设计备选方案： <ul><li>设计3-5个最佳</li><li>备选方案差异要比较明显</li><li>避免局限于已熟悉的技术</li><li>备选阶段关注技术选型，而非技术细节</li></ul></li><li>评估和选择备选方案： <ul><li>360度环评： 性能、可用性、成本、复杂度、安全性、可拓展性等</li><li>评估是否遵守架构设计的三大原则</li><li>指导思想： 最简派（选择最简单）、最牛派（技术上看起来最牛）、最熟派（熟悉哪个用哪个）、领导派（领导拍板）</li><li>通过质量属性优先级排序，选择最优备选方案，质量属性如： 性能、复杂度、成本、可拓展性、可用性</li></ul></li><li>详细方案设计： <ul><li>深入技术细节和原理，避免成为PPT架构师</li><li>通过分步骤、分阶段、分系统等方式，降低方案复杂度，逐步演化，避免单一细节推翻整体方案</li><li>如果方案过于复杂，可采用设计团队的方式，避免1、2个设计师时可能的思维盲点或经验盲区</li></ul></li></ul><h3 id="实践" tabindex="-1">实践 <a class="header-anchor" href="#实践" aria-label="Permalink to &quot;实践&quot;">​</a></h3><ul><li>技术需求方案输出可考虑设计3-5个方案备选，罗列明显差异，避免局限于已熟悉的技术；拆分技术选型评审和方案详细评审，避免在不必要的方向上花太多时间梳理方案；</li><li>技术方案评审时，从方案的性能、可用性、成本、复杂度、安全性、可拓展性角度，思考是否符合合适、简单、演化原则。</li></ul><h2 id="第四章-高性能架构模式" tabindex="-1">第四章 高性能架构模式 <a class="header-anchor" href="#第四章-高性能架构模式" aria-label="Permalink to &quot;第四章 高性能架构模式&quot;">​</a></h2><h3 id="关系数据库" tabindex="-1">关系数据库 <a class="header-anchor" href="#关系数据库" aria-label="Permalink to &quot;关系数据库&quot;">​</a></h3><h4 id="读写分离" tabindex="-1">读写分离 <a class="header-anchor" href="#读写分离" aria-label="Permalink to &quot;读写分离&quot;">​</a></h4><p>主机负责写，从机负责读</p><ul><li>常见问题： 如果大量写入，导致主从复制延迟，eg： 注册后立即登录</li><li>解决方案： <ul><li>方案一： 写操作后的读操作都在主机上读。对业务侵入和影响比较大</li><li>方案二： 读从机失败后，读主机。如果存在攻击，可能导致主机压力过大</li><li>方案三： 关键业务读写都在主机上，非关键业务读写分离。可能导致非关键业务读取数据不一致</li></ul></li></ul><h4 id="分库分表" tabindex="-1">分库分表 <a class="header-anchor" href="#分库分表" aria-label="Permalink to &quot;分库分表&quot;">​</a></h4><p>分散数据库的读写操作压力</p><h5 id="业务分库" tabindex="-1">业务分库 <a class="header-anchor" href="#业务分库" aria-label="Permalink to &quot;业务分库&quot;">​</a></h5><ul><li>常见问题： <ul><li>join操作： 无法跨库join</li><li>跨库事务： 无法跨库事务</li><li>成本问题： 业务复杂度增加，维护成本增加，如果考虑备份，双倍成本</li></ul></li></ul><h5 id="垂直分表" tabindex="-1">垂直分表 <a class="header-anchor" href="#垂直分表" aria-label="Permalink to &quot;垂直分表&quot;">​</a></h5><ul><li>常见问题： <ul><li>可能查询一次就变成两次</li></ul></li></ul><h5 id="水平分表" tabindex="-1">水平分表 <a class="header-anchor" href="#水平分表" aria-label="Permalink to &quot;水平分表&quot;">​</a></h5><ul><li>水平分表算法： <ul><li>范围路由： 选取有序的数据列作为路由的条件，eg: 创建时间，1～10000的时间放在一个库 <ul><li>常见问题： <ul><li>如果分段太少，会导致切分后子表数量过多，增加维护复杂度；如果分段太多，会导致单表性能问题</li><li>数据分布不均匀</li></ul></li></ul></li><li>hash路由： 取某列的值进行hash运算，eg: 取用户ID，然后<code>%10</code>取模 <ul><li>常见问题： <ul><li>增加子表时，需要重新分布数据</li></ul></li></ul></li><li>配置路由： 建一张独立的路由表记录路由信息，eg: 用户ID，表名 <ul><li>常见问题： <ul><li>所有查询必须多查询一次</li><li>如果路由表过大，还是会存在性能瓶颈问题</li></ul></li></ul></li></ul></li><li>常见问题： <ul><li>join操作： 如果需join查询，需多次join再汇总</li><li>count操作： 需每个表count相加；或者记一张中间表，但每次insert/delete都要更新中间表</li><li>orderby操作： 需每个表orderby后再汇总排序</li></ul></li><li>实现方式： <ul><li>程序代码封装： 抽象到数据访问层实现读写分离、分库分表。 <ul><li>特点： <ul><li>实现简单，可以根据业务做定制化</li><li>每个编程语言需自己实现一次，无法通用</li><li>故障情况下，所有系统需修改和重启</li></ul></li><li>开源方案： 淘宝的TTDL</li></ul></li><li>数据库中间件封装： 独立一套系统出来，实现读写分离、分库分表 <ul><li>特点： <ul><li>通用性强，可以支持多种编程语言</li><li>故障情况下，只需修改中间件，无需修改业务系统</li><li>中间件性能要求高</li></ul></li><li>开源方案： MySQLRouter、Atlas</li></ul></li></ul></li></ul><h3 id="关系数据库的问题" tabindex="-1">关系数据库的问题 <a class="header-anchor" href="#关系数据库的问题" aria-label="Permalink to &quot;关系数据库的问题&quot;">​</a></h3><ul><li>无法存储数据结构： 需将数据拆分成多个行记录存储</li><li>schema扩展不方便： 需要修改表结构</li><li>大数据场景IO高： 即使取某一列进行计算，也会读取整行数据</li><li>全文搜索功能较弱： like整表扫描匹配，性能较差</li></ul><h3 id="nosql" tabindex="-1">NoSQL <a class="header-anchor" href="#nosql" aria-label="Permalink to &quot;NoSQL&quot;">​</a></h3><p>NoSQL（Not Only SQL）通过牺牲一些ACID特性，换取更高的性能和可拓展性。常见四种方案：</p><ul><li>K-V存储： 解决关系型数据库无法存储数据结构问题。eg: Redis</li><li>文档数据库： 解决关系型数据库schema约束问题。eg: MongoDB</li><li>列式数据库： 解决大数据场景IO高问题。eg: HBase</li><li>全文搜索引擎： 解决全文搜索功能较弱问题。eg: ElasticSearch</li></ul><h4 id="k-v存储" tabindex="-1">K-V存储 <a class="header-anchor" href="#k-v存储" aria-label="Permalink to &quot;K-V存储&quot;">​</a></h4><p>Key是数据的标识，Value是具体的数据。eg: Redis的数组操作LPOP，关系型数据库需执行多次操作（创建编号、查询、删除、更新编号），而NoSQL只需一次操作</p><ul><li>特点： <ul><li>确保隔离性和一致性（I和C），会牺牲原子性和持久性（A和D） <ul><li>原子性（A）： Redis事务不支持回滚操作，也不会中断后续操作</li><li>一致性（C）： Redis事务能保证事务开始之前和结束之后，数据库完整性没有被破坏</li><li>隔离性（I）： Redis是单进程单线程的工作模式。如果某一客户端执行大量的命令，会阻塞其他客户端的命令</li><li>持久性（D）： Redis支持RDB和AOF两种持久化方式。RDB是定时备份（可能数据还在内存中未写入磁盘），AOF是追加写日志（执行命令后立即写入磁盘，可能丢失1条命令数据）</li></ul></li></ul></li></ul><h4 id="文档数据库" tabindex="-1">文档数据库 <a class="header-anchor" href="#文档数据库" aria-label="Permalink to &quot;文档数据库&quot;">​</a></h4><p>文档数据库的数据以文档的形式存储，文档是一种类似JSON的结构，可以存储不同结构的文档。</p><ul><li>特点： <ul><li>新增字段简单，无需事先执行DDL（Data Definition Language，数据定义语言），可以存储不同结构的文档</li><li>不支持事务</li><li>不支持join操作</li></ul></li></ul><h4 id="列式数据库" tabindex="-1">列式数据库 <a class="header-anchor" href="#列式数据库" aria-label="Permalink to &quot;列式数据库&quot;">​</a></h4><p>列式数据库将数据按列存储，如果一行数据是1KB，其中需要查询的列只有1B，那么只需读取1B数据。一般用于离线的大数据分析和统计场景</p><ul><li>特点： <ul><li>多个列读取时效率高，因为列存储是按行存储在一起的，只需读取需要的列</li><li>多个列写操作时，可能会导致部分列写成功，部分列写失败，导致数据不一致</li></ul></li></ul><h4 id="全文搜索引擎" tabindex="-1">全文搜索引擎 <a class="header-anchor" href="#全文搜索引擎" aria-label="Permalink to &quot;全文搜索引擎&quot;">​</a></h4><p>关系型数据库是根据索引实现快速查询，但是like会会整表扫描，效率低下；全文搜索的条件会随意组合，如果建更多索引会导致索引数量特别多。 全文搜索引擎是通过倒排索引（又称反向索引、置入档案或反向档案）的索引方式，建立单词到文档的索引。</p><h3 id="缓存的架构设计要点" tabindex="-1">缓存的架构设计要点 <a class="header-anchor" href="#缓存的架构设计要点" aria-label="Permalink to &quot;缓存的架构设计要点&quot;">​</a></h3><p>单台memcached服务器简单的key-value查询可以达到5w以上的TPS。实现方式是： RDBMS拉数据存储到memcached，首次查询时，memcached没有数据，再去RDBMS查询，然后存储到memcached，下次查询直接从memcached查询。</p><ul><li>缓存穿透： 缓存中查不到数据，需要查存储系统，可能是数据不存在，也可能是缓存数据生成需要耗费大量的时间或资源。eg: 爬虫拉取数据 <ul><li>解决方案： <ul><li>空对象缓存</li><li>慢查询场景过滤爬虫，但可能影响SEO和推广</li></ul></li></ul></li><li>缓存雪崩： 当缓存失效后，高并发场景下，会有大量请求打到存储系统，可能导致存储系统造成巨大性能压力，进而拖慢整个系统 <ul><li>解决方案： <ul><li>更新锁： 缓存失效时，加锁，只有一个线程去更新缓存，其他线程要么等待锁释放后重新读缓存，要么直接返回默认值</li><li>后台更新： 由后台线程更新缓存，缓存永久有效，后台定时更新缓存。如果内存不足清除后，期间访问返回默认值，后台更新缓存 <ul><li>定时更新策略： 间隔一段时间更新缓存，判断如果缓存过期，立即更新缓存</li><li>消息队列策略： 缓存失败时，通过消息队列通知后台更新缓存</li></ul></li><li>缓存预热： 系统上线后，直接把数据加载到缓存中，而不是等到请求时再加载</li></ul></li></ul></li><li>缓存热点： 热点数据集中在同一份缓存数据，可能导致缓存服务器压力过大 <ul><li>解决方案： <ul><li>分布式缓存： 将热点数据分散到不同的缓存服务器。 eg: 微博大V每条微博都可以生成100份缓存，分散到100台缓存服务器</li></ul></li></ul></li></ul><h3 id="实践-1" tabindex="-1">实践 <a class="header-anchor" href="#实践-1" aria-label="Permalink to &quot;实践&quot;">​</a></h3><ul><li>在高并发场景下，如果查询接口的qps比较低，可以通过缓存预热的方式，在业务上线前将缓存加载好，缓存的更新机制可通过消息队列监听事件触发时，更新缓存。</li></ul><h2 id="第五章-计算高性能" tabindex="-1">第五章 计算高性能 <a class="header-anchor" href="#第五章-计算高性能" aria-label="Permalink to &quot;第五章 计算高性能&quot;">​</a></h2><p>主要集中在两方面：</p><ul><li>单服务器高性能</li><li>服务器集群高性能</li><li>编码高性能</li></ul><h3 id="单服务器高性能" tabindex="-1">单服务器高性能 <a class="header-anchor" href="#单服务器高性能" aria-label="Permalink to &quot;单服务器高性能&quot;">​</a></h3><h4 id="网络编程模型" tabindex="-1">网络编程模型 <a class="header-anchor" href="#网络编程模型" aria-label="Permalink to &quot;网络编程模型&quot;">​</a></h4><p>关键设计在于如何管理和处理请求，与以下模型相关：</p><ul><li>I/O模型： 阻塞、非阻塞、同步、异步</li><li>进程模型： 单进程、多进程、多线程</li></ul><h5 id="ppc模型" tabindex="-1">PPC模型 <a class="header-anchor" href="#ppc模型" aria-label="Permalink to &quot;PPC模型&quot;">​</a></h5><p>PPC(Process Per Connection)模型是一种进程模型，每个连接对应一个进程。优点是简单，缺点是进程切换开销大，进程资源占用大，父子进程通信复杂，不适合高并发场景</p><h5 id="prefork模型" tabindex="-1">prefork模型 <a class="header-anchor" href="#prefork模型" aria-label="Permalink to &quot;prefork模型&quot;">​</a></h5><p>prefork模型与PPC模型的区别是，prefork模型是预先fork出多个进程。</p><h5 id="tpc模型" tabindex="-1">TPC模型 <a class="header-anchor" href="#tpc模型" aria-label="Permalink to &quot;TPC模型&quot;">​</a></h5><p>TPC(Thread Per Connection)模型是一种线程模型，每个连接对应一个线程。优点是线程切换开销小，与进程共享内存，线程通信比PPC模型简单，缺点是可能会导致死锁问题、线程异常的内存越界问题，CPU线程调度和切换开销大，不适合高并发场景</p><h5 id="prethread模型" tabindex="-1">prethread模型 <a class="header-anchor" href="#prethread模型" aria-label="Permalink to &quot;prethread模型&quot;">​</a></h5><p>prethread模型与TPC模型的区别是，prethread模型是预先创建多个线程。</p><h5 id="reactor模型" tabindex="-1">Reactor模型 <a class="header-anchor" href="#reactor模型" aria-label="Permalink to &quot;Reactor模型&quot;">​</a></h5><p>又名Dispatcher模型，是一种I/O模型，主要用于处理高并发的I/O操作。Reactor模型的核心是，当事件发生时，调用事件处理器处理事件。Reactor模型的优点是高并发、高性能。不同编程语言，对应支持的进程、线程、Reactor模型不同。常见以下三种方案：</p><ul><li>单Reactor单进程单线程： 没有进程间通信，没有进程竞争，没有锁，性能高。但是，单进程模型下，无法充分利用多核CPU、多线程的优势；</li><li>单Reactor单进程多线程： 可以共享进程内存，所以进程间通信简单；但是Reactor承担了所有事件的监听和响应，只在主进程进行，所以可能会成为性能瓶颈；</li><li>多Reactor多进程多线程： 主进程负责监听事件，子进程负责处理事件。子进程之间不会有竞争，可以充分利用多核CPU、多线程的优势。例如：Nginx</li></ul><h5 id="proactor模型" tabindex="-1">Proactor模型 <a class="header-anchor" href="#proactor模型" aria-label="Permalink to &quot;Proactor模型&quot;">​</a></h5><p>是非阻塞同步网络模型，与Reactor模型的区别是，Reactor模型是同步I/O，Proactor模型是异步I/O。异步处理完了再通知应用程序，适用于高并发场景</p><h4 id="集群高性能" tabindex="-1">集群高性能 <a class="header-anchor" href="#集群高性能" aria-label="Permalink to &quot;集群高性能&quot;">​</a></h4><p>通过负载均衡将请求分发到不同机器上。</p><h5 id="负载均衡分类" tabindex="-1">负载均衡分类 <a class="header-anchor" href="#负载均衡分类" aria-label="Permalink to &quot;负载均衡分类&quot;">​</a></h5><ul><li>DNS负载均衡： 根据不同地理位置，DNS解析到不同IP地址。缺点是更新不及时、拓展性差、无法根据服务器负载情况分配请求</li><li>硬件负载均衡： 通过类似基础网络设备做分流，支持多种负载均衡算法。缺点是价格昂贵、维护成本高</li><li>软件负载均衡： 如Nginx、LVS。优点是价格低、维护成本低、支持多种负载均衡算法。缺点是性能低于硬件负载均衡</li></ul><h5 id="负载均衡架构" tabindex="-1">负载均衡架构 <a class="header-anchor" href="#负载均衡架构" aria-label="Permalink to &quot;负载均衡架构&quot;">​</a></h5><p>常见组合为：</p><ul><li>DNS负载均衡实现地理级别的负载均衡</li><li>硬件负载均衡实现集群级别的负载均衡</li><li>软件负载均衡实现服务器级别的负载均衡</li></ul><h5 id="负载均衡算法" tabindex="-1">负载均衡算法 <a class="header-anchor" href="#负载均衡算法" aria-label="Permalink to &quot;负载均衡算法&quot;">​</a></h5><p>算法分类：</p><ul><li>任务平分类： 根据比例、权重均分任务 <ul><li>轮询： 每次请求按顺序分配到不同服务器，不考虑服务器的性能</li><li>加权轮询： 每次请求按权重分配到不同服务器</li></ul></li><li>负载均衡类： 依据CPU负载、连接数、I/O使用率、网卡吞吐量等来均衡系统的压力 <ul><li>负载最低优先： 每次请求分配到负载最低的服务器，需指定负载计算方式，明确负载计算的时间间隔，如果太短可能早晨频繁波动，太长可能导致负载不均衡。负载计算算法容易成为性能瓶颈。</li></ul></li><li>性能最优类： 根据服务器响应速度进行分配 <ul><li>响应速度最快优先： 收集和分析每台服务器每个任务的响应时间，再进行分配。如果采样率过高，则会导致性能消耗较大，采样率过低则会导致结果不准确</li></ul></li><li>Hash类： 根据请求的hash值来分配请求 <ul><li>源地址Hash： 同一个源地址分配到同一台服务器上进行处理</li><li>ID Hash： 根据请求的ID参数来分配请求</li></ul></li></ul><h2 id="第六章-高可用架构模式" tabindex="-1">第六章 高可用架构模式 <a class="header-anchor" href="#第六章-高可用架构模式" aria-label="Permalink to &quot;第六章 高可用架构模式&quot;">​</a></h2><h3 id="cap理论" tabindex="-1">CAP理论 <a class="header-anchor" href="#cap理论" aria-label="Permalink to &quot;CAP理论&quot;">​</a></h3><p>强调一致性和可用性的权衡。系统不可能同时满足以下三个特性：</p><ul><li>一致性（Consistency）： 客户端读操作能返回最新的写操作结果</li><li>可用性（Availability）： 非故障节点在合理的时间里返回合理的响应（不是错误和超时的响应）</li><li>分区容错性（Partition Tolerance）： 当出现网络分区(可能是丢包、连接中断、阻塞)后，系统能够继续工作</li></ul><h4 id="cap应用" tabindex="-1">CAP应用 <a class="header-anchor" href="#cap应用" aria-label="Permalink to &quot;CAP应用&quot;">​</a></h4><p>在分布式环境下，因为网络无法做到100%可靠，所以P无法舍弃，所以只能选择CP或AP架构。这里的CP或AP架构是网络分区时，相对侧重C或A。</p><ul><li>CP架构： 当网络异常，数据查询时，表现为提示客户端错误</li><li>AP架构： 当网络异常，数据查询时，表现为返回旧数据</li></ul><h3 id="acid理论" tabindex="-1">ACID理论 <a class="header-anchor" href="#acid理论" aria-label="Permalink to &quot;ACID理论&quot;">​</a></h3><p>强调一致性。数据库为了保证事务的正确性而提出的，一个事务要么全完成，要么全不完成，没有中间态。包含四个约束：</p><ul><li>原子性（Atomicity）</li><li>一致性（Consistency）： 事务前后数据完整性保持一致</li><li>隔离性（Isolation）： 事务之间互不干扰</li><li>持久性（Durability）： 事务一旦提交，数据就会永久保存</li></ul><h3 id="base理论" tabindex="-1">BASE理论 <a class="header-anchor" href="#base理论" aria-label="Permalink to &quot;BASE理论&quot;">​</a></h3><p>强调可用性。是CAP理论中AP方案的延伸，是为了解决分布式系统的一致性问题。BASE是指：</p><ul><li>基本可用（Basically Available）： 分布式系统故障时，允许损失部分可用性，保证核心功能可用</li><li>软状态（Soft State）： 允许系统中存在中间状态，不同节点数据可能不一致</li><li>最终一致性（Eventually Consistent）： 系统中的所有数据副本经过一定时间后，最终能够达到一致状态</li></ul><h2 id="第七章-故障模式与影响分析" tabindex="-1">第七章 故障模式与影响分析 <a class="header-anchor" href="#第七章-故障模式与影响分析" aria-label="Permalink to &quot;第七章 故障模式与影响分析&quot;">​</a></h2><p>FMEA（Failure Mode and Effect Analysis）是一种系统性的、有方法的分析方法，用于识别和评估系统中的潜在故障模式及其影响，从而提高系统的可靠性。</p><h3 id="fmea方法" tabindex="-1">FMEA方法 <a class="header-anchor" href="#fmea方法" aria-label="Permalink to &quot;FMEA方法&quot;">​</a></h3><p>FMEA分析表应包含以下内容：</p><ul><li>功能点： 业务层面划分的功能，非技术层面</li><li>故障模式： 系统可能出现的故障点和故障形式，eg: MySQL响应达3s</li><li>故障影响： 当发生故障模式中的故障时，功能点会有什么影响，eg: 20%用户无法访问</li><li>严重程度： 根据功能点重要程度、故障影响范围、功能点受损程度判断，高中低分级</li><li>故障原因</li><li>故障概率： 可重点按硬件、开源系统、自研系统维度评估，预留资源投入，高中低分级</li><li>风险程度： 根据严重程度和故障概率评估，高中低分级</li><li>已有措施： 针对故障原因，系统是否提供了对呀措施应对 eg: 告警、容错、自恢复</li><li>规避措施： 降低故障发生概率而做的事，可以是技术或管理手段 eg: 冗余、定时重启</li><li>解决措施： 为了解决问题而做的事，如果某个故障既可以规避又可以解决，通常优先采用解决措施</li><li>后续规划： 综合前面的分析，检查哪些故障缺乏对应措施和不足，按优先级排序针对性优化</li></ul><h2 id="第八章-存储高可用" tabindex="-1">第八章 存储高可用 <a class="header-anchor" href="#第八章-存储高可用" aria-label="Permalink to &quot;第八章 存储高可用&quot;">​</a></h2><p>通过将数据复制到多个设备，以数据冗余的方式提高数据的可用性，主要的复杂性再如何应对复制延迟和中断导致的数据不一致问题，通常需思考以下问题：</p><ul><li>数据如何复制</li><li>各节点职责是什么</li><li>如何应对复制延迟</li><li>如何应对复制中断</li></ul><h3 id="主备复制" tabindex="-1">主备复制 <a class="header-anchor" href="#主备复制" aria-label="Permalink to &quot;主备复制&quot;">​</a></h3><p><img src="'+t+'" alt="alt text"></p><p>详细设计：</p><ul><li>主机存储数据，复制到备机</li><li>正常情况下，读写在主机上进行，备机不对外提供读写服务</li><li>主机故障情况下，且主机短时间内不能自动恢复（eg:硬盘损坏），则人工将备机主动升级为主机</li><li>主机不能恢复，写入主机但还没备份到备机的数据会丢失，需要人工排查和恢复，数据可能丢失，业务需考虑该风险应对方案</li><li>如果复制延迟了，主机又宕机了，可能会丢失较多数据，需要监控复制延迟情况，延迟较多需告警</li></ul><p>优点：</p><ul><li>主备切换时无感知</li><li>主备双方只需要数据传输，无复杂操作</li></ul><p>缺点：</p><ul><li>备机只用作备份用途，没有读写操作，硬件成本浪费</li><li>故障需要人工干预，无法自动恢复</li></ul><h3 id="主从复制" tabindex="-1">主从复制 <a class="header-anchor" href="#主从复制" aria-label="Permalink to &quot;主从复制&quot;">​</a></h3><p><img src="'+o+'" alt="alt text"></p><p>相比主备复制方案，差异点是：</p><ul><li>写操作发送到主机，读操作发送到主机或从机，算法可以是随机或者轮询读等</li><li>主机故障时，无法写入，但不影响读操作</li></ul><h3 id="主备倒换和主从倒换" tabindex="-1">主备倒换和主从倒换 <a class="header-anchor" href="#主备倒换和主从倒换" aria-label="Permalink to &quot;主备倒换和主从倒换&quot;">​</a></h3><p>主要解决主备复制和主从复制的以下问题：</p><ul><li>主机故障后，无法进行写操作</li><li>如果主机无法恢复，需要指定新的主机角色</li></ul><p>详细设计：</p><ul><li>主备间状态判断： 状态传递的渠道和状态检测的内容 <ul><li>状态传递的渠道： 是相互连接还是第三方仲裁？</li><li>状态检测的内容： eg: 机器是否掉电，进程是否存在等</li></ul></li><li>倒换决策： <ul><li>倒换时机： 明确什么情况下切换主机 eg: 进程不存在，主机响应超2s，3分钟内连续重启3次等</li><li>倒换策略： 明确主机恢复后，应该成为备机还是主机</li><li>自动程度： 全自动还是半自动 eg: 人工切换主机</li></ul></li><li>数据冲突解决： 主备切换后，旧主机的新数据未备份到新主机，可能导致数据不一致</li></ul><h4 id="常见架构" tabindex="-1">常见架构 <a class="header-anchor" href="#常见架构" aria-label="Permalink to &quot;常见架构&quot;">​</a></h4><h5 id="互连式" tabindex="-1">互连式 <a class="header-anchor" href="#互连式" aria-label="Permalink to &quot;互连式&quot;">​</a></h5><p><img src="'+h+'" alt="alt text"></p><ul><li>主机发送状态给备机，或者备机主动获取主机状态</li><li>主备机器通过网络+串口通道连接，进行状态传递通信</li><li>如果状态传递的通道出现异常（eg:网线拔了），可能导致备机误以为主机宕机，升级为主机 <ul><li>可通过增加更多通道增强传递可靠性，但是只是降低了出现概率，无法完全避免</li></ul></li></ul><h5 id="中介式" tabindex="-1">中介式 <a class="header-anchor" href="#中介式" aria-label="Permalink to &quot;中介式&quot;">​</a></h5><p><img src="'+u+'" alt="alt text"></p><ul><li>主备设备连接到中介设备，中介设备负责主备设备的状态传递和切换</li><li>代价就是实现中介设备的高可用</li><li>可使用开源成熟方案 eg: Zookeeper</li></ul><h5 id="模拟式" tabindex="-1">模拟式 <a class="header-anchor" href="#模拟式" aria-label="Permalink to &quot;模拟式&quot;">​</a></h5><p><img src="'+n+'" alt="alt text"></p><ul><li>通过模拟读写操作来探测主机状态，如果主机无法响应，备机升级为主机</li></ul><h3 id="主主复制" tabindex="-1">主主复制 <a class="header-anchor" href="#主主复制" aria-label="Permalink to &quot;主主复制&quot;">​</a></h3><p><img src="'+s+'" alt="alt text"></p><ul><li>两台机器都是主机，通过互相将数据复制给对方，客户端客挑选任意机器进行写操作</li><li>详细设计与主备复制相似，但不存在主备倒换概念</li><li>需保障数据能够双向复制，数据在大多数情况下不允许双向复制 eg: 插入记录id自增、库存扣减</li><li>适用于临时性、可丢失、可覆盖的数据场景</li></ul><h3 id="数据集群" tabindex="-1">数据集群 <a class="header-anchor" href="#数据集群" aria-label="Permalink to &quot;数据集群&quot;">​</a></h3><p>单机运算能力有限，集群处理存储和处理问题</p><h4 id="数据集中集群" tabindex="-1">数据集中集群 <a class="header-anchor" href="#数据集中集群" aria-label="Permalink to &quot;数据集中集群&quot;">​</a></h4><ul><li>类似主备、主从架构，主机读写，从机只读</li><li>由于服务器数量更多，会出现多条复制通道、主机状态检测的性能问题，主机选举决策问题</li></ul><h4 id="数据分散集群" tabindex="-1">数据分散集群 <a class="header-anchor" href="#数据分散集群" aria-label="Permalink to &quot;数据分散集群&quot;">​</a></h4><p><img src="'+d+'" alt="alt text"></p><ul><li>无主从概念，每台机器都是主机，数据分散存储在多台机器上</li><li>要有一个角色执行数据分配算法，可以是独立的也可以是选举出来的服务器</li><li>设计上需通过算法保障均衡性，避免数据倾斜；需考虑容错性，服务器故障时分区数据需分配到其他服务器；需考虑可伸缩性，扩容时需自动将数据迁移到新服务器</li></ul><h4 id="分布式事务算法" tabindex="-1">分布式事务算法 <a class="header-anchor" href="#分布式事务算法" aria-label="Permalink to &quot;分布式事务算法&quot;">​</a></h4><p>数据的一致性可采用事务实现，在集群中该数据分布在不同节点上，节点间只能通过消息通信，所以事务依赖消息通知实现。但消息可能丢失，所以存在分布式事务算法</p><ul><li>两阶段提交(2PC: Two-phase commit protocol)： 通过协调者和参与者两个角色，协调者发起事务，参与者执行事务，协调者发起提交，参与者执行提交。 <ul><li>缺点: <ul><li>同步阻塞： 协调者和参与者需等待对方响应的消息，过程中节点处于阻塞状态，可能导致阻塞</li><li>状态不一致： 部分参与者未收到提交消息，超时直接ROLLBACK了</li><li>单点故障： 协调者故障，整个事务无法进行，参与者一直等待</li></ul></li></ul></li><li>三阶段提交(3PC: Three-phase commit protocol)： 在两阶段提交基础上，增加了超时机制，防止参与者长时间阻塞</li></ul><h4 id="分布式一致性算法" tabindex="-1">分布式一致性算法 <a class="header-anchor" href="#分布式一致性算法" aria-label="Permalink to &quot;分布式一致性算法&quot;">​</a></h4><p>确保分散在多个节点的数据的一致性，以满足CP架构要求</p><h5 id="复制状态机技术" tabindex="-1">复制状态机技术 <a class="header-anchor" href="#复制状态机技术" aria-label="Permalink to &quot;复制状态机技术&quot;">​</a></h5><p>常用的算法有： Paxos（最权威）、Raft、Zab</p><p>主要角色：</p><ul><li>副本： 每个节点都有一份完整状态机副本</li><li>状态机： 接受输入和执行操作，流转状态</li><li>算法： 协调各副本处理逻辑，保证数据一致性</li></ul><h3 id="数据分区" tabindex="-1">数据分区 <a class="header-anchor" href="#数据分区" aria-label="Permalink to &quot;数据分区&quot;">​</a></h3><p>基于地理级别的故障设计高可用架构，一个良好的设计需考虑多个方面：</p><ul><li>数据量： 如果只是水平扩容，可能导致较高的运维成本；</li><li>分区规则： 可按洲际、国家、城市分区，主要考虑业务范围和成本因素等；</li><li>复制规则： 部分数据如果受影响，整体数据不会受影响，但需考虑恢复损坏或丢失的这部分数据，所以需要复制方案，常见以下备份架构 <ul><li>集中式： 多地区数据集中备份到一个地区，特点是成本高，易扩展，简单</li><li>互备式： 每个分区备份另一个分区的数据，特点是成本低，但是复杂度高，拓展时要考虑备份方向，不易扩展</li><li>独立式： 每个分区都有自己独立的备份中心，特点是成本高（比集中式高，不同的场地成本），易拓展，简单</li></ul></li></ul><h2 id="第九章-计算高可用" tabindex="-1">第九章 计算高可用 <a class="header-anchor" href="#第九章-计算高可用" aria-label="Permalink to &quot;第九章 计算高可用&quot;">​</a></h2><p>当部分硬件损坏时，计算任务可正常运行，通过冗余更多服务器达到计算高可用。复杂度主要在于任务管理上，如何在任务失败时重新分配到新服务器执行。</p><h3 id="主备架构" tabindex="-1">主备架构 <a class="header-anchor" href="#主备架构" aria-label="Permalink to &quot;主备架构&quot;">​</a></h3><p><img src="'+c+'" alt="alt text"></p><p>类似于存储高可用的主备架构，主要分为冷备和温备架构。</p><ul><li>冷备： 程序和配置文件都准备好，但是不运行，需要手动启动。优点是节约资源</li><li>温备： 程序和配置文件都准备好，且运行，但是不对外提供服务，需将任务分配器的任务请求切换为备机即可。优点是减少手工操作</li></ul><h3 id="主从架构" tabindex="-1">主从架构 <a class="header-anchor" href="#主从架构" aria-label="Permalink to &quot;主从架构&quot;">​</a></h3><p><img src="'+p+'" alt="alt text"></p><p>主机和从机都对外提供服务，主机负责写操作，从机负责读操作。主机故障时，从机升级为主机。</p><h3 id="对称集群" tabindex="-1">对称集群 <a class="header-anchor" href="#对称集群" aria-label="Permalink to &quot;对称集群&quot;">​</a></h3><p><img src="'+b+'" alt="alt text"></p><p>任务分配器检查服务状态，并分配任务到多台服务器上，每台服务器都可以执行任务。</p><ul><li>任务分配： 常用轮询和随机算法；</li><li>状态检测： 服务器状态（宕机、网络是否正常等）、任务状态（是否执行成功等）、心跳检测（是否正常运行）；</li></ul><h4 id="非对称集群" tabindex="-1">非对称集群 <a class="header-anchor" href="#非对称集群" aria-label="Permalink to &quot;非对称集群&quot;">​</a></h4><p><img src="'+q+'" alt="alt text"></p><p>不同角色的服务器承担不同的职责，如任务分配器、任务执行器、任务监控器等。</p><h2 id="第十章-业务高可用" tabindex="-1">第十章 业务高可用 <a class="header-anchor" href="#第十章-业务高可用" aria-label="Permalink to &quot;第十章 业务高可用&quot;">​</a></h2><h3 id="异地多活" tabindex="-1">异地多活 <a class="header-anchor" href="#异地多活" aria-label="Permalink to &quot;异地多活&quot;">​</a></h3><p>如果业务规模很大，业务系统中断会带来很大影响，那么就需要对业务做异地多活架构，避免单点故障。异地多活架构分为以下几种：</p><ul><li>同城异区： 部署在同一个城市不同市区的多个机房。从复杂度、成本、故障发生概率综合考虑，是最优选择</li><li>跨城异地： 部署在不同城市的多个机房。由于距离较远，数据传输时不可控因素会非常多，可能导致数据不一致问题</li><li>跨国异地： 部署在不同国家的多个机房。由于跨国，可能会受到政策、网络等因素影响，延时可能达好几秒。主要应用场景有： <ul><li>为不同地区提供服务，eg: 亚马逊中国和亚马逊美国帐号不互通</li><li>只读类业务做多活</li></ul></li></ul><h4 id="关键设计" tabindex="-1">关键设计 <a class="header-anchor" href="#关键设计" aria-label="Permalink to &quot;关键设计&quot;">​</a></h4><ul><li>关键业务做多活： 并非所有业务都适合做多活 eg: 注册和登录，确保登录多活，注册单活，避免数据一致性问题</li><li>核心数据一致： <ul><li>减少异地距离，搭建高速网络；</li><li>尽量减少数据同步，只同步核心业务数据；</li><li>保障最终一致性，不保证实时一致性；</li></ul></li><li>采用多种数据同步手段： <ul><li>消息队列同步；</li><li>二次读取数据（请求重试）；</li><li>存储系统主从复制；</li><li>根据sessionId回源读取；</li><li>回源失败，重新生成数据；</li></ul></li><li>只保证绝大部分用户的异地多活： <ul><li>将实时操作改为异步操作，eg: 转账拆分成转账申请和转账操作，转账申请异地多活，转账操作单活；</li><li>不可用情况下，通过一些措施安抚用户； eg: 挂公告、事后补偿、事后通知等；</li></ul></li></ul><h4 id="设计步骤" tabindex="-1">设计步骤 <a class="header-anchor" href="#设计步骤" aria-label="Permalink to &quot;设计步骤&quot;">​</a></h4><ol><li>业务分级： 挑选核心业务、访问量大、产生大量收入进行多活</li><li>数据分类：</li></ol><ul><li>数据量级</li><li>唯一性要求： 避免多机生成唯一id不一致</li><li>实时性要求： 实时性要多高</li><li>可丢失性： 是否允许数据丢失</li><li>可恢复性： 是否可恢复、重置、重复生成（eg:重登）</li></ul><ol start="3"><li>数据同步： 选择合适的同步方案，存储系统同同步、消息队列同步、重复生成策略</li><li>异常处理：</li></ol><ul><li>目的： 问题发生时，减少影响范围；问题修复后，修正异常数据；补充用户损失</li><li>方案： <ul><li>多通道同步： 同时使用MySQL主从同步和消息队列同步。</li><li>日志记录： 服务器存储一份日志，数据库存储一份，避免数据库宕机丢失日志</li><li>用户补偿</li></ul></li></ul><h3 id="接口故障" tabindex="-1">接口故障 <a class="header-anchor" href="#接口故障" aria-label="Permalink to &quot;接口故障&quot;">​</a></h3><p>原因分为内部和外部原因，可能是程序死循环、慢查询、黑客攻击等等，应对措施有：</p><ul><li>降级： 通过系统后门降级、独立降级系统，以禁用部分功能，保障其他功能</li><li>熔断： 通过熔断器，当接口调用失败率达到一定阈值，自动熔断，避免雪崩</li><li>限流： 通过限流器，限制接口调用频率，避免雪崩 <ul><li>基于请求限流： 限制某个指标的累积上限</li><li>基于资源限流： 限制某个资源的累积上限</li></ul></li><li>排队： 通过消息队列，将请求排队，避免瞬间高并发</li></ul><h2 id="第十一章-可拓展模式" tabindex="-1">第十一章 可拓展模式 <a class="header-anchor" href="#第十一章-可拓展模式" aria-label="Permalink to &quot;第十一章 可拓展模式&quot;">​</a></h2><p>通过拆分模块，拓展时仅需修改某一部分即可，无需到处修改</p><h3 id="可拓展的基本思想" tabindex="-1">可拓展的基本思想 <a class="header-anchor" href="#可拓展的基本思想" aria-label="Permalink to &quot;可拓展的基本思想&quot;">​</a></h3><p>系统不同的的拆分方式会带来不同程度的拓展方式，常见的拆分方式有三种：</p><ul><li>面向流程拆分： 业务流程拆成多个阶段，常用分层架构</li><li>面向服务拆分： 系统拆分成多个服务，常用SOA、微服务架构</li><li>面向功能拆分： 系统拆分成多个功能，常用微内核架构，拆分多个插件实现</li></ul><p>可在不同系统和服务层面采用不同的架构组合使用。</p><h2 id="第十二章-分层架构" tabindex="-1">第十二章 分层架构 <a class="header-anchor" href="#第十二章-分层架构" aria-label="Permalink to &quot;第十二章 分层架构&quot;">​</a></h2><p>也称N层架构，2层常见C/S、B/S架构，3层常见MVC、MVP架构，通常比较复杂的系统才会达到或超过5层。可通过分层实现层层递进，隔离关注点。分层架构关键点：</p><ul><li>层级不能太多： <ul><li>可能会导致分层不明显，容易产生分层争议</li><li>可能会导致性能浪费，但多数场景下可忽略不计</li></ul></li><li>分层约束不可省略： 再简单的业务都需要分层处理</li></ul><h2 id="第十三章-soa架构" tabindex="-1">第十三章 SOA架构 <a class="header-anchor" href="#第十三章-soa架构" aria-label="Permalink to &quot;第十三章 SOA架构&quot;">​</a></h2><p>面向服务架构（Service Oriented Architecture），用于解决系统的重复建设问题。SOA提出三个关键概念：</p><ul><li>服务： 业务功能的抽象，提供某种功能的服务</li><li>ESB： 企业服务总线，服务之间的通信桥梁，通常包含消息格式转换、错误处理、路由等功能。客户端需通过该服务转发到其他服务，所以往往这一层会比较庞大、复杂和低效</li><li>松耦合： 服务之间的耦合度低，一个服务的变化不会影响其他服务</li></ul><h2 id="第十四章-微服务" tabindex="-1">第十四章 微服务 <a class="header-anchor" href="#第十四章-微服务" aria-label="Permalink to &quot;第十四章 微服务&quot;">​</a></h2><p>微服务是SOA架构的一种具体的实现方式，去掉了ESB，改为使用HTTP实现。微服务架构的特点：</p><ul><li>服务粒度细： 可能导致整体系统服务间关系会变得复杂，调用链变长，问题定位困难</li><li>服务通信简化： 推荐统一协议和格式，如RESTful协议、RPC协议，无须通过ESB实现</li><li>要求快速交付： 要有对应的自动化测试、持续集成、自动化部署等敏捷开发相关的最佳实践，避免部署成本过高问题</li><li>互联网应用场景</li></ul><h3 id="微服务最佳实践" tabindex="-1">微服务最佳实践 <a class="header-anchor" href="#微服务最佳实践" aria-label="Permalink to &quot;微服务最佳实践&quot;">​</a></h3><p>围绕以下3个方面：</p><ul><li>small： 服务粒度拆分合理，不要过大。</li><li>lightweight： 规模小</li><li>automated： 基础设施健全</li></ul><h4 id="服务粒度" tabindex="-1">服务粒度 <a class="header-anchor" href="#服务粒度" aria-label="Permalink to &quot;服务粒度&quot;">​</a></h4><p>确认服务拆分数量，可依据以下理论：</p><ul><li>“两个披萨”理论： 每个团队人数不能多到两个披萨都不够吃</li><li>“三个火枪手”理论： 建议3人维护1个微服务，既有备份又能满足复杂度</li></ul><h4 id="拆分方法" tabindex="-1">拆分方法 <a class="header-anchor" href="#拆分方法" aria-label="Permalink to &quot;拆分方法&quot;">​</a></h4><p>可基于以下方法组合使用：</p><ul><li>方法一 基于业务逻辑拆分： 根据团队可支持的服务数量和职责范围划分</li><li>方法二 基于可拓展拆分： 根据成熟和改动不大的放在一个子系统，粒度粗一些。不稳定的服务粒度细一些，避免开发时影响已有成熟功能</li><li>方法三 基于可靠性拆分： 核心和非核心服务拆分开，保证核心服务高可用。好处在于，避免非核心服务影响核心服务、核心服务高可用方案可更简单、降低高可用成本</li><li>方法三 基于性能拆分： 性能要求高或性能压力高的模块拆分出来，避免因性能影响其他服务</li></ul><h4 id="基础设施" tabindex="-1">基础设施 <a class="header-anchor" href="#基础设施" aria-label="Permalink to &quot;基础设施&quot;">​</a></h4><p><img src="'+m+'" alt=""></p><p>微服务并没有减少复杂度，只是将复杂度从ESB转移到基础设施。</p><ul><li>自动化测试</li><li>自动化部署</li><li>配置中心</li><li>接口框架： 一般规范通信协议（HTTP/RESET、RPC）、数据格式（JSON/XML）、错误码、接口文档等</li><li>API网关： 用于统一管理微服务的接口，提供统一的访问入口，可实现权限控制、传输加密、流量控制、监控等功能</li><li>服务发现 <ul><li>自理式： 从服务注册中心获取服务地址，客户端直接调用服务地址。</li><li>代理式： 客户端调用代理服务器（Load Balance），代理服务器从服务注册中心获取服务地址，代理服务器再调用服务。代理服务器可能成为性能瓶颈</li></ul></li><li>服务路由</li><li>服务容错： 常见方式有请求重试、流控和服务隔离 <ul><li>服务隔离： 分为主动、被动和手动隔离。主动隔离是根据服务异常状态，主动从服务发现注销；被动隔离是根据服务发现系统设置的规则（连接状态、响应时间等）灯盘是否故障而注销。</li></ul></li><li>服务监控： 集中日志到一起以便实时快速检索</li><li>服务跟踪： 用于追踪请求的调用链路，定位问题，链路染色。其中关键技术点有 <ul><li>标注点： 一个全局的标注，可以是一个特殊ID，通过该ID串联起整个调用链路</li><li>跟踪树和span： 请求到响应的过程称为span，多个span组成一个跟踪树</li></ul></li><li>服务安全： 保障业务和数据的安全性，通常通过配置中心实现接入安全策略和数据安全策略 <ul><li>接入安全： 只有经过授权，某个微服务才能访问另一个微服务，否则会被拒绝</li><li>数据安全： 只有经过授权，某个微服务才能访问某些数据，否则会被拒绝</li><li>传输安全： 确保数据在传输过程中不会被窃取或篡改</li></ul></li></ul><h2 id="第十五章-微内核架构" tabindex="-1">第十五章 微内核架构 <a class="header-anchor" href="#第十五章-微内核架构" aria-label="Permalink to &quot;第十五章 微内核架构&quot;">​</a></h2><p><img src="'+P+'" alt=""></p><p>又称插件化架构，是一种面向功能进行拆分的可拓展性架构。</p><p>微内核架构包含两类组件：</p><ul><li>核心系统（core system）： 负责和具体业务功能无关的通用功能，功能比较稳定，不会因为业务功能拓展而不断修改</li><li>插件模块（plug-in modules）： 负责实现具体的业务逻辑，功能比较不稳定，会因为业务功能拓展而不断拓展</li></ul><h3 id="设计关键点" tabindex="-1">设计关键点 <a class="header-anchor" href="#设计关键点" aria-label="Permalink to &quot;设计关键点&quot;">​</a></h3><ul><li>插件管理： 负责明确插件可用性，加载位置、时机等。常见的实现方式是插件注册表机制</li><li>插件连接： 通过制定插件和系统的连接规范，按规范实现接入，核心系统按规范加载即可。常见的连接机制有OSGi（Eclipse使用）、消息模式、依赖注入（Spring使用）、分布式协议（RPC、HTTP）等。</li><li>插件通信： 业务运行过程中，必然会出现某个业务流程需要多个插件协作，由于插件之间是松耦合的，所以需依赖核心系统提供的通信机制进行通信，常见的通信机制有事件驱动、消息队列</li></ul><h3 id="osgi架构" tabindex="-1">OSGi架构 <a class="header-anchor" href="#osgi架构" aria-label="Permalink to &quot;OSGi架构&quot;">​</a></h3><p><img src="'+f+'" alt=""></p><p>OSGi（Open Service Gateway Initiative）开放服务网关倡议，具备动态化、热插拔、高可服用性、高效性、拓展性等优点。架构逻辑层次为：</p><ul><li>模块层（Module层）： 负责插件管理功能。插件又称Bundle，每个Bundle都有一份元数据文件，包含了Bundle的基本信息，包括名称、描述、需要导入的包、输出的包等。核心系统会将这些信息加载到系统中用于后续使用</li><li>生命周期层（Lifecycle层）： 负责完成插件连接功能，提供了执行时模块管理、模块对底层框架的访问。生命周期层明确定义Bundle的生命周期（安装、更新、启动、停止、卸载），Bundle需按规范实现各个操作</li><li>服务层（Service层）： 负责完成插件通信功能。OSGi提供了服务注册的功能，插件可注册能力到服务注册中心。</li></ul><h3 id="规则引擎" tabindex="-1">规则引擎 <a class="header-anchor" href="#规则引擎" aria-label="Permalink to &quot;规则引擎&quot;">​</a></h3><p>从结构上来看，也是属于微内核架构的一种具体实现。基本架构如下：</p><p><img src="'+k+'" alt=""></p><p>规则引擎系统的特点：</p><ul><li>可拓展： 不改动业务系统下，可拓展新的业务功能</li><li>易理解： 通过自然语言描述让业务人员可理解和操作</li><li>高效率： 系统提供对应的可视化工具，方便业务人员快速配置新业务</li></ul><h2 id="第十六章-消息队列设计实战" tabindex="-1">第十六章 消息队列设计实战 <a class="header-anchor" href="#第十六章-消息队列设计实战" aria-label="Permalink to &quot;第十六章 消息队列设计实战&quot;">​</a></h2><h3 id="需求分析" tabindex="-1">需求分析 <a class="header-anchor" href="#需求分析" aria-label="Permalink to &quot;需求分析&quot;">​</a></h3><p>了解需求背景、业务规模、团队规模、技术栈等</p><h3 id="架构设计" tabindex="-1">架构设计 <a class="header-anchor" href="#架构设计" aria-label="Permalink to &quot;架构设计&quot;">​</a></h3><ol><li>识别复杂度：</li></ol><ul><li>是否需要高性能： 当前业务一天处理的消息量，识别TPS和QPS，峰值取平均值的3倍，性能冗余量按4倍计算</li><li>是否需要高可用： 当消息丢失了，影响程度会多高</li><li>是否需要高可拓展性： 消息队列功能单一，无需考虑太多</li><li>其他维度： 是否需要安全性等</li></ul><ol start="2"><li>设计备选方案： 整理业界成熟方案、自建方案一（按成熟方案的逻辑实现）、自建方案二（其他方式实现），梳理各功能点大致实现思路</li><li>评估和选择备选方案：</li></ol><ul><li>开发、运维、测试等多方站在各自维度评估优劣势</li><li>整理360度环评表，根据复杂度、硬件成本、可运维性、可靠性、人力投入成本等维度评估备选方案</li><li>得出决策依据</li></ul><ol start="4"><li>细化方案： 根据选定方案，细化具体功能设计、接入方式、高性能、高可用等实现细节</li></ol><h2 id="第十七章-互联网架构演进" tabindex="-1">第十七章 互联网架构演进 <a class="header-anchor" href="#第十七章-互联网架构演进" aria-label="Permalink to &quot;第十七章 互联网架构演进&quot;">​</a></h2><p>互联网业务发展时期分为以下几个阶段： <img src="'+x+'" alt=""></p><ul><li>产品类业务： 用户会追求更好的体验，所以技术创新推动业务发展</li><li>服务类业务： 用户会追求更大的规模，所以业务发展推动技术创新</li><li>规模决定一切，而不是一味地追求技术创新</li><li>架构师需基于当前发展阶段识别当前系统面临的主要复杂度</li></ul><h2 id="第十八章-互联网架构模板" tabindex="-1">第十八章 互联网架构模板 <a class="header-anchor" href="#第十八章-互联网架构模板" aria-label="Permalink to &quot;第十八章 互联网架构模板&quot;">​</a></h2><p>互联网技术公司的大部分技术点如下（不同公司只是具体实现上有差异，不会跳出这个范畴）： <img src="'+g+'" alt=""></p><h3 id="存储层技术" tabindex="-1">存储层技术 <a class="header-anchor" href="#存储层技术" aria-label="Permalink to &quot;存储层技术&quot;">​</a></h3><ul><li>SQL： MySQL、PostgreSQL等</li><li>NoSQL： Memcache、Redis、MongoDB等</li><li>小文件存储： 淘宝的TFS、京东的JFS、Facebook的Haystack等</li><li>大文件存储： Hadoop、Hbase、Storm、Hive等</li></ul><h3 id="开发层技术" tabindex="-1">开发层技术 <a class="header-anchor" href="#开发层技术" aria-label="Permalink to &quot;开发层技术&quot;">​</a></h3><ul><li>开发框架： 选择成熟的框架而非新技术，避免踩坑，eg: Java的SpringMVC、Ruby的Ruby on Rails、Python的Django等</li><li>Web服务器： Tomcat、Nginx、Apache等</li><li>容器： Docker、Kubernetes等</li></ul><h3 id="服务层技术" tabindex="-1">服务层技术 <a class="header-anchor" href="#服务层技术" aria-label="Permalink to &quot;服务层技术&quot;">​</a></h3><ul><li>配置中心： 管理各个系统的配置，方便查找和协作、按规则检查配置是否合法</li><li>服务中心： 通过服务名字系统或者服务总线系统，实现服务的注册、发现、调用、监控等功能 <ul><li>服务名字系统： 将目标服务的IP和端口返回给调用方</li><li>服务总线系统： 将目标服务接口响应数据返回给调用方，较为低效</li></ul></li><li>消息队列： Kafka、RocketMQ、ActiveMQ等，将网状结构变成线性结构，比较难保障高性能、高可用、消息时序性、消息事务性等</li></ul><h3 id="网络层技术" tabindex="-1">网络层技术 <a class="header-anchor" href="#网络层技术" aria-label="Permalink to &quot;网络层技术&quot;">​</a></h3><ul><li>负载均衡： DNS或者Nginx、LVS、F5等</li><li>CDN</li><li>多机房： 同城多机房、跨城多机房、跨国多机房</li><li>多中心</li></ul><h3 id="用户层技术" tabindex="-1">用户层技术 <a class="header-anchor" href="#用户层技术" aria-label="Permalink to &quot;用户层技术&quot;">​</a></h3><ul><li>用户管理： CAS、OAuth2.0</li><li>消息推送： iOS的APNS、Android的GCM（国内不能用，不同定制Android都不一样）、第三方推送服务（友盟推送、极光推送）</li><li>存储云和图片云</li></ul><h3 id="业务层技术" tabindex="-1">业务层技术 <a class="header-anchor" href="#业务层技术" aria-label="Permalink to &quot;业务层技术&quot;">​</a></h3><ul><li>将系统拆分成多个子系统</li><li>使用Facade设计模式，将子系统的接口封装成一个接口，对外提供服务</li></ul><h3 id="平台技术" tabindex="-1">平台技术 <a class="header-anchor" href="#平台技术" aria-label="Permalink to &quot;平台技术&quot;">​</a></h3><ul><li>运维平台： <ul><li>主要功能： 配置、部署、监控、应急</li><li>核心设计要素： 标准化、平台化、自动化、可视化</li></ul></li><li>测试平台： 主要功能是单元测试、集成测试、接口测试、性能测试等，提升测试效率 <ul><li>自动化测试： 由用例管理、资源管理、数据管理和任务管理组成</li></ul></li><li>数据平台： 负责数据管理、数据分析和数据应用 <ul><li>数据管理： 职责包含数据采集、数据存储、数据访问、数据安全</li><li>数据分析： 包含统计统计、数据挖掘、机器学习、深度学习等细分领域</li><li>数据应用： 如数据报表、异常检测、推荐、广告等</li></ul></li><li>管理平台： 负责身份认证、权限控制</li></ul><h2 id="第十九章-架构重构" tabindex="-1">第十九章 架构重构 <a class="header-anchor" href="#第十九章-架构重构" aria-label="Permalink to &quot;第十九章 架构重构&quot;">​</a></h2><h3 id="合纵连横" tabindex="-1">合纵连横 <a class="header-anchor" href="#合纵连横" aria-label="Permalink to &quot;合纵连横&quot;">​</a></h3><ul><li>合纵： 与利益相关方沟通好，做好事实、数据支撑，对重构达成共识，避免重构过程中反复争执</li><li>连横： 推动其他团队参与重构，换位思考、合作共赢、关注长期。推动不力可协调高层。</li></ul><h3 id="运筹帷幄" tabindex="-1">运筹帷幄 <a class="header-anchor" href="#运筹帷幄" aria-label="Permalink to &quot;运筹帷幄&quot;">​</a></h3><ul><li>梳理总体重构策略，分阶段重构</li><li>日常问题中，耗时较多的，应在最早阶段重构解决</li><li>每个阶段的问题梳理好，做好分类，先易后难处理，划分优先级推进</li></ul><h3 id="项目管理" tabindex="-1">项目管理 <a class="header-anchor" href="#项目管理" aria-label="Permalink to &quot;项目管理&quot;">​</a></h3><p>做好项目过程管理，不同系统，问题的优先级不同</p><h2 id="第二十章-开源系统" tabindex="-1">第二十章 开源系统 <a class="header-anchor" href="#第二十章-开源系统" aria-label="Permalink to &quot;第二十章 开源系统&quot;">​</a></h2><h3 id="选-如何选择开源项目时" tabindex="-1">选： 如何选择开源项目时 <a class="header-anchor" href="#选-如何选择开源项目时" aria-label="Permalink to &quot;选： 如何选择开源项目时&quot;">​</a></h3><ul><li>考虑是否满足业务要求</li><li>成熟度： 高版本号、使用的公司数量多、社区活跃度高、发帖数高、帖子回复和处理速度快</li><li>可运维： 日志完善、支持以各种形式查看系统运行状态、有故障检查和恢复能力</li></ul><h3 id="用-如何使用开源方案" tabindex="-1">用： 如何使用开源方案 <a class="header-anchor" href="#用-如何使用开源方案" aria-label="Permalink to &quot;用： 如何使用开源方案&quot;">​</a></h3><ul><li>读设计文档或白皮书，了解设计原理</li><li>了解每个配置作用和影响，识别关键配置项</li><li>测试充足： 多场景测试、压力测试、故障测试</li><li>灰度上线，避免未知风险</li><li>做好故障备份方案</li></ul><h3 id="改-如何二次开发开源系统" tabindex="-1">改： 如何二次开发开源系统 <a class="header-anchor" href="#改-如何二次开发开源系统" aria-label="Permalink to &quot;改： 如何二次开发开源系统&quot;">​</a></h3><ul><li>避免改动&amp;造轮子，可能投入成本较高，尽量通过提issue或PR的方式解决</li><li>考虑开发辅助工具，如监控、日志、报警等</li></ul>',277)])])}const I=i(S,[["render",_]]);export{B as __pageData,I as default};
