import{_ as i,o as l,c as e,ae as t}from"./chunks/framework.CLid5Cgc.js";const s="/assets/C17C41FD-B1D1-4564-AE26-EB778E5E52CC.SChxWPsF.png",r="/assets/589D153A-FC29-4E74-98F1-1D00DAA0A8A6.oMc_5luB.png",h="/assets/B910A7E7-60A0-46D9-B15D-40C75DCEF342.BmqJk360.png",n="/assets/90A085BB-0161-40C9-9ACE-17A787B281B9.DN5X-M_K.png",m=JSON.parse('{"title":"前端架构设计","description":"","frontmatter":{"title":"前端架构设计"},"headers":[],"relativePath":"notes/qian-duan-jia-gou-she-ji/index.md","filePath":"notes/qian-duan-jia-gou-she-ji/index.md"}'),o={name:"notes/qian-duan-jia-gou-she-ji/index.md"};function d(u,a,c,b,p,k){return l(),e("div",null,[...a[0]||(a[0]=[t('<h1 id="前端架构设计" tabindex="-1">前端架构设计 <a class="header-anchor" href="#前端架构设计" aria-label="Permalink to &quot;前端架构设计&quot;">​</a></h1><h2 id="架构风格" tabindex="-1">架构风格 <a class="header-anchor" href="#架构风格" aria-label="Permalink to &quot;架构风格&quot;">​</a></h2><ol><li>分层架构：每一层为上层提供服务</li><li>MVC架构：模型、视图和控制器职责分离</li><li>发布/订阅架构：基于事件的架构风格</li><li>管道和过滤器：处理数据流的架构模式</li></ol><h2 id="架构设计" tabindex="-1">架构设计 <a class="header-anchor" href="#架构设计" aria-label="Permalink to &quot;架构设计&quot;">​</a></h2><h3 id="层次设计" tabindex="-1">层次设计 <a class="header-anchor" href="#层次设计" aria-label="Permalink to &quot;层次设计&quot;">​</a></h3><p>层次金字塔，自上而下设计架构，至下而上完善架构</p><ol><li>系统级： 整个系统如何与外界通信，如：前后的分离架构、微前端架构</li><li>应用级： 应用外部如何共享组件、通信等，如：模式库、组件库、设计系统</li><li>模块级： 应用内部如何模块化、数据和状态管理等，如：组件化、模块化</li><li>代码级： 从基础设施保障架构实施，如：规范、原则、质量</li></ol><h2 id="代码架构" tabindex="-1">代码架构 <a class="header-anchor" href="#代码架构" aria-label="Permalink to &quot;代码架构&quot;">​</a></h2><p>主要是对代码命名风格的规范统一</p><h3 id="测试策略" tabindex="-1">测试策略 <a class="header-anchor" href="#测试策略" aria-label="Permalink to &quot;测试策略&quot;">​</a></h3><ol><li>E2E测试</li><li>服务测试</li><li>组件测试</li><li>单元测试</li></ol><h2 id="构建流" tabindex="-1">构建流 <a class="header-anchor" href="#构建流" aria-label="Permalink to &quot;构建流&quot;">​</a></h2><p>构建流中包含编译，如：gulp是基于管道（Pipe）思想的流编程，而webpack仅负责将代码编译为浏览器可执行的es5代码。</p><h2 id="设计风格指南" tabindex="-1">设计风格指南 <a class="header-anchor" href="#设计风格指南" aria-label="Permalink to &quot;设计风格指南&quot;">​</a></h2><ul><li>设计原则：大小、位置、间距等</li><li>色彩：主题色、功能色、中性色</li><li>文字排印：字体、大小、对齐方式等</li><li>布局</li><li>组件库</li><li>文档、图片规范等</li></ul><h3 id="沉淀" tabindex="-1">沉淀 <a class="header-anchor" href="#沉淀" aria-label="Permalink to &quot;沉淀&quot;">​</a></h3><ul><li>组件库</li><li>模式库：组件库中用到的通用代码</li></ul><h2 id="微前端架构" tabindex="-1">微前端架构 <a class="header-anchor" href="#微前端架构" aria-label="Permalink to &quot;微前端架构&quot;">​</a></h2><h3 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h3><ul><li>应用自治：减少模块间依赖</li><li>单一职责：要求页面间关联性低</li><li>技术栈无关</li></ul><h3 id="拆分原则" tabindex="-1">拆分原则 <a class="header-anchor" href="#拆分原则" aria-label="Permalink to &quot;拆分原则&quot;">​</a></h3><ul><li>按照业务拆分</li><li>按照权限拆分</li><li>按照变更的频率拆分</li><li>按照组织结构拆分</li><li>跟随后端微服务拆分</li></ul><h3 id="拆分方式" tabindex="-1">拆分方式 <a class="header-anchor" href="#拆分方式" aria-label="Permalink to &quot;拆分方式&quot;">​</a></h3><ul><li>路由分发 <img src="'+s+'" alt="3d139a6b7a368c0052ae545809eec54d"></li><li>前端微服务化：是微服务架构在前端的实施，每个前端应用都是完全独立（技术栈、开发、部署、构建独立）、自主运行的，最后通过模块化的方式组合出完整的前端应用。通常配备single-spa <img src="'+r+'" alt="bb8d5becf1039cff87a40f9fb52218c9"></li><li>微应用：即在开发时，应用都是以单一、微小应用的形式存在，而在运行时，则通过构建系统合并这些应用，组合成一个新的应用。 <img src="'+h+'" alt="3074e591b82169ecbaf2668f42f0f7f5"></li><li>微件化：微件（widget），指的是一段可以直接嵌入在应用上运行的代码，它由开发人员预先编译好，在加载时不需要再做任何修改或者编译。 <img src="'+n+`" alt="2f9833614f68724088779a1ef9290c6a"></li><li>前端容器化：用iframe承载应用</li><li>应用组件化：使用Web Components</li></ul><h3 id="通信机制建立" tabindex="-1">通信机制建立 <a class="header-anchor" href="#通信机制建立" aria-label="Permalink to &quot;通信机制建立&quot;">​</a></h3><h4 id="bridge-eventbus" tabindex="-1">bridge eventbus <a class="header-anchor" href="#bridge-eventbus" aria-label="Permalink to &quot;bridge eventbus&quot;">​</a></h4><p>用于跨层级的通讯，由底层建立，遵守制定通信规则。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 监听的事件名称由 应用名称 : 动作 + 名称 组成</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bridge.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;basic:update-menu&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h2 id="渐进式架构" tabindex="-1">渐进式架构 <a class="header-anchor" href="#渐进式架构" aria-label="Permalink to &quot;渐进式架构&quot;">​</a></h2><p>几种方式：</p><ul><li>更新</li><li>重构</li><li>迁移</li><li>重写</li><li>重新架构</li></ul><h3 id="更新" tabindex="-1">更新 <a class="header-anchor" href="#更新" aria-label="Permalink to &quot;更新&quot;">​</a></h3><p>让旧应用的依赖和环境不断更新，以免成为一个不可维护的遗留系统</p><h4 id="升级项" tabindex="-1">升级项 <a class="header-anchor" href="#升级项" aria-label="Permalink to &quot;升级项&quot;">​</a></h4><ul><li>依赖升级</li><li>框架升级</li><li>语言升级</li></ul><h4 id="指定维护策略" tabindex="-1">指定维护策略 <a class="header-anchor" href="#指定维护策略" aria-label="Permalink to &quot;指定维护策略&quot;">​</a></h4><ul><li>合理的时间间隔，如三个月一次</li><li>定期检查依赖或使用工具自动检测</li><li>为更新预留时间和精力</li><li>准备文档策略，以记录过程中遇到的问题</li></ul><h3 id="常见问题" tabindex="-1">常见问题 <a class="header-anchor" href="#常见问题" aria-label="Permalink to &quot;常见问题&quot;">​</a></h3><ul><li>重写的意义是否重大</li><li>时间成本能否接受</li><li>代码中隐藏的业务能否发现</li></ul><h2 id="参考文献" tabindex="-1">参考文献 <a class="header-anchor" href="#参考文献" aria-label="Permalink to &quot;参考文献&quot;">​</a></h2><ul><li>前端架构：从入门到微前端</li><li>UX最佳实践：提高用户体验影响力的艺术</li></ul>`,41)])])}const f=i(o,[["render",d]]);export{m as __pageData,f as default};
