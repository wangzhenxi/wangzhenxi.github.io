(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{391:function(v,_,a){v.exports=a.p+"assets/img/image.9ab13a51.png"},392:function(v,_,a){v.exports=a.p+"assets/img/image-1.313d7505.png"},393:function(v,_,a){v.exports=a.p+"assets/img/image-2.1c7ca12f.png"},394:function(v,_,a){v.exports=a.p+"assets/img/image-3.128988d5.png"},395:function(v,_,a){v.exports=a.p+"assets/img/image-4.f848d16c.png"},396:function(v,_,a){v.exports=a.p+"assets/img/image-5.b04b27b0.png"},397:function(v,_,a){v.exports=a.p+"assets/img/image-6.641a0915.png"},398:function(v,_,a){v.exports=a.p+"assets/img/image-7.8f91fc13.png"},399:function(v,_,a){v.exports=a.p+"assets/img/image-8.7977441e.png"},400:function(v,_,a){v.exports=a.p+"assets/img/image-9.fb35fbc8.png"},401:function(v,_,a){v.exports=a.p+"assets/img/image-10.2d361460.png"},483:function(v,_,a){"use strict";a.r(_);var t=a(19),i=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"从零开始学架构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#从零开始学架构"}},[v._v("#")]),v._v(" 从零开始学架构")]),v._v(" "),_("h2",{attrs:{id:"第一章-概念和基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第一章-概念和基础"}},[v._v("#")]),v._v(" 第一章 概念和基础")]),v._v(" "),_("h3",{attrs:{id:"软件架构是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#软件架构是什么"}},[v._v("#")]),v._v(" 软件架构是什么？")]),v._v(" "),_("p",[v._v("软件架构是指软件系统的顶层结构，而架构设计的目的是为了解决软件复杂度。")]),v._v(" "),_("ul",[_("li",[v._v("避免为了高指标而做架构设计，有时候并不需要架构设计，会造成更高的项目成本")]),v._v(" "),_("li",[v._v("机器语言、汇编语言、高级语言的演进，解决了编码复杂度")])]),v._v(" "),_("h4",{attrs:{id:"系统架构的结构该如何拆解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#系统架构的结构该如何拆解"}},[v._v("#")]),v._v(" 系统架构的结构该如何拆解？")]),v._v(" "),_("p",[v._v("可基于以下维度拆解：")]),v._v(" "),_("ul",[_("li",[v._v("系统、子系统： 由一群有关联的个体所组成，根据某种规则运作。")]),v._v(" "),_("li",[v._v("模块、组件： 从逻辑角度拆分得到的单元是模块，负责职责分离；从物理角度拆分得到的单元是组件，负责单元复用，独立可替换。")]),v._v(" "),_("li",[v._v("框架、架构： 框架提供组件的规范；架构提供系统的结构。")])]),v._v(" "),_("h3",{attrs:{id:"架构设计的复杂度来源于什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#架构设计的复杂度来源于什么"}},[v._v("#")]),v._v(" 架构设计的复杂度来源于什么？")]),v._v(" "),_("ul",[_("li",[v._v("高性能，理论上会存在上限，优化只能逼近该上限，有以下手段：\n"),_("ul",[_("li",[v._v("单进程 -> 多进程")]),v._v(" "),_("li",[v._v("单线程 -> 多线程")]),v._v(" "),_("li",[v._v("单机 -> 多机")]),v._v(" "),_("li",[v._v("单任务 -> 多任务")])])]),v._v(" "),_("li",[v._v("高可用：\n"),_("ul",[_("li",[v._v("机器冗余，包含连接管理，分配算法（n主n备）")]),v._v(" "),_("li",[v._v("存储高可用（一致性、可用性、分区容错性最多满足两个）")]),v._v(" "),_("li",[v._v("状态决策： 独裁式（单点监测）、协商式（监测&投票）、民主式（去中心化）")])])]),v._v(" "),_("li",[v._v("可拓展，可通过面向对象、设计模式解决：\n"),_("ul",[_("li",[v._v("预测变化： 预测可能错误，不能每个设计点都考虑可拓展性")]),v._v(" "),_("li",[v._v("应对变化：\n"),_("ul",[_("li",[v._v("方法一： 基本架构拆分变化层和稳定层")]),v._v(" "),_("li",[v._v("方法二： 提炼出抽象层和实现层，抽象层保持稳定，实现层支持定制开发")])])])])]),v._v(" "),_("li",[v._v("低成本\n"),_("ul",[_("li",[v._v("和高性能、高可用冲突，所以属于架构设计的附加约束")]),v._v(" "),_("li",[v._v("往往通过新技术引入实现")])])]),v._v(" "),_("li",[v._v("安全性：\n"),_("ul",[_("li",[v._v("功能安全、架构安全")])])])]),v._v(" "),_("h2",{attrs:{id:"第二章-架构设计原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第二章-架构设计原则"}},[v._v("#")]),v._v(" 第二章 架构设计原则")]),v._v(" "),_("h3",{attrs:{id:"架构设计三原则是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#架构设计三原则是什么"}},[v._v("#")]),v._v(" 架构设计三原则是什么？")]),v._v(" "),_("ul",[_("li",[v._v("合适原则： 合适由于业界领先")]),v._v(" "),_("li",[v._v("简单原则： 简单优于复杂")]),v._v(" "),_("li",[v._v("演化原则： 演化优于一步到位")])]),v._v(" "),_("h4",{attrs:{id:"合适原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#合适原则"}},[v._v("#")]),v._v(" 合适原则")]),v._v(" "),_("p",[v._v("结合当前人力、条件、业务等约束，将资源整合发挥最大功效，快速落地，而不是生搬硬套。")]),v._v(" "),_("p",[v._v("常见问题：")]),v._v(" "),_("ul",[_("li",[v._v("没有那么多人，却想干那么多活")]),v._v(" "),_("li",[v._v("没有那么多卓越的业务场景积累，却想创造业界领先方案")])]),v._v(" "),_("h4",{attrs:{id:"简单原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简单原则"}},[v._v("#")]),v._v(" 简单原则")]),v._v(" "),_("p",[v._v("简单优于复杂。")]),v._v(" "),_("ul",[_("li",[v._v("结构复杂性： 当组成的组件越多，组件的稳定性会直接影响系统的稳定性")]),v._v(" "),_("li",[v._v("逻辑复杂性： 逻辑杂糅在一个组件里，改动影响范围大")])]),v._v(" "),_("h4",{attrs:{id:"演化原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#演化原则"}},[v._v("#")]),v._v(" 演化原则")]),v._v(" "),_("p",[v._v("架构应满足当下业务需要，随着业务变化而变化")]),v._v(" "),_("ul",[_("li",[v._v("设计过程中，保留优秀设计，修复缺陷设计，去掉无用设计")]),v._v(" "),_("li",[v._v("业务变化时，架构要拓展、重构、甚至重写")]),v._v(" "),_("li",[v._v("避免生搬硬套大公司做法，要根据自身业务特点，逐步演化")])]),v._v(" "),_("h2",{attrs:{id:"第三章-架构设计流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第三章-架构设计流程"}},[v._v("#")]),v._v(" 第三章 架构设计流程")]),v._v(" "),_("ul",[_("li",[v._v("识别复杂度： 罗列复杂度问题，优先级排序处理")]),v._v(" "),_("li",[v._v("设计备选方案：\n"),_("ul",[_("li",[v._v("设计3-5个最佳")]),v._v(" "),_("li",[v._v("备选方案差异要比较明显")]),v._v(" "),_("li",[v._v("避免局限于已熟悉的技术")]),v._v(" "),_("li",[v._v("备选阶段关注技术选型，而非技术细节")])])]),v._v(" "),_("li",[v._v("评估和选择备选方案：\n"),_("ul",[_("li",[v._v("360度环评： 性能、可用性、成本、复杂度、安全性、可拓展性等")]),v._v(" "),_("li",[v._v("评估是否遵守架构设计的三大原则")]),v._v(" "),_("li",[v._v("指导思想： 最简派（选择最简单）、最牛派（技术上看起来最牛）、最熟派（熟悉哪个用哪个）、领导派（领导拍板）")]),v._v(" "),_("li",[v._v("通过质量属性优先级排序，选择最优备选方案，质量属性如： 性能、复杂度、成本、可拓展性、可用性")])])]),v._v(" "),_("li",[v._v("详细方案设计：\n"),_("ul",[_("li",[v._v("深入技术细节和原理，避免成为PPT架构师")]),v._v(" "),_("li",[v._v("通过分步骤、分阶段、分系统等方式，降低方案复杂度，逐步演化，避免单一细节推翻整体方案")]),v._v(" "),_("li",[v._v("如果方案过于复杂，可采用设计团队的方式，避免1、2个设计师时可能的思维盲点或经验盲区")])])])]),v._v(" "),_("h3",{attrs:{id:"实践"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实践"}},[v._v("#")]),v._v(" 实践")]),v._v(" "),_("ul",[_("li",[v._v("技术需求方案输出可考虑设计3-5个方案备选，罗列明显差异，避免局限于已熟悉的技术；拆分技术选型评审和方案详细评审，避免在不必要的方向上花太多时间梳理方案；")]),v._v(" "),_("li",[v._v("技术方案评审时，从方案的性能、可用性、成本、复杂度、安全性、可拓展性角度，思考是否符合合适、简单、演化原则。")])]),v._v(" "),_("h2",{attrs:{id:"第四章-高性能架构模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第四章-高性能架构模式"}},[v._v("#")]),v._v(" 第四章 高性能架构模式")]),v._v(" "),_("h3",{attrs:{id:"关系数据库"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#关系数据库"}},[v._v("#")]),v._v(" 关系数据库")]),v._v(" "),_("h4",{attrs:{id:"读写分离"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#读写分离"}},[v._v("#")]),v._v(" 读写分离")]),v._v(" "),_("p",[v._v("主机负责写，从机负责读")]),v._v(" "),_("ul",[_("li",[v._v("常见问题： 如果大量写入，导致主从复制延迟，eg： 注册后立即登录")]),v._v(" "),_("li",[v._v("解决方案：\n"),_("ul",[_("li",[v._v("方案一： 写操作后的读操作都在主机上读。对业务侵入和影响比较大")]),v._v(" "),_("li",[v._v("方案二： 读从机失败后，读主机。如果存在攻击，可能导致主机压力过大")]),v._v(" "),_("li",[v._v("方案三： 关键业务读写都在主机上，非关键业务读写分离。可能导致非关键业务读取数据不一致")])])])]),v._v(" "),_("h4",{attrs:{id:"分库分表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分库分表"}},[v._v("#")]),v._v(" 分库分表")]),v._v(" "),_("p",[v._v("分散数据库的读写操作压力")]),v._v(" "),_("h5",{attrs:{id:"业务分库"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#业务分库"}},[v._v("#")]),v._v(" 业务分库")]),v._v(" "),_("ul",[_("li",[v._v("常见问题：\n"),_("ul",[_("li",[v._v("join操作： 无法跨库join")]),v._v(" "),_("li",[v._v("跨库事务： 无法跨库事务")]),v._v(" "),_("li",[v._v("成本问题： 业务复杂度增加，维护成本增加，如果考虑备份，双倍成本")])])])]),v._v(" "),_("h5",{attrs:{id:"垂直分表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垂直分表"}},[v._v("#")]),v._v(" 垂直分表")]),v._v(" "),_("ul",[_("li",[v._v("常见问题：\n"),_("ul",[_("li",[v._v("可能查询一次就变成两次")])])])]),v._v(" "),_("h5",{attrs:{id:"水平分表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#水平分表"}},[v._v("#")]),v._v(" 水平分表")]),v._v(" "),_("ul",[_("li",[v._v("水平分表算法：\n"),_("ul",[_("li",[v._v("范围路由： 选取有序的数据列作为路由的条件，eg: 创建时间，1～10000的时间放在一个库\n"),_("ul",[_("li",[v._v("常见问题：\n"),_("ul",[_("li",[v._v("如果分段太少，会导致切分后子表数量过多，增加维护复杂度；如果分段太多，会导致单表性能问题")]),v._v(" "),_("li",[v._v("数据分布不均匀")])])])])]),v._v(" "),_("li",[v._v("hash路由： 取某列的值进行hash运算，eg: 取用户ID，然后"),_("code",[v._v("%10")]),v._v("取模\n"),_("ul",[_("li",[v._v("常见问题：\n"),_("ul",[_("li",[v._v("增加子表时，需要重新分布数据")])])])])]),v._v(" "),_("li",[v._v("配置路由：  建一张独立的路由表记录路由信息，eg: 用户ID，表名\n"),_("ul",[_("li",[v._v("常见问题：\n"),_("ul",[_("li",[v._v("所有查询必须多查询一次")]),v._v(" "),_("li",[v._v("如果路由表过大，还是会存在性能瓶颈问题")])])])])])])]),v._v(" "),_("li",[v._v("常见问题：\n"),_("ul",[_("li",[v._v("join操作： 如果需join查询，需多次join再汇总")]),v._v(" "),_("li",[v._v("count操作： 需每个表count相加；或者记一张中间表，但每次insert/delete都要更新中间表")]),v._v(" "),_("li",[v._v("orderby操作： 需每个表orderby后再汇总排序")])])]),v._v(" "),_("li",[v._v("实现方式：\n"),_("ul",[_("li",[v._v("程序代码封装： 抽象到数据访问层实现读写分离、分库分表。\n"),_("ul",[_("li",[v._v("特点：\n"),_("ul",[_("li",[v._v("实现简单，可以根据业务做定制化")]),v._v(" "),_("li",[v._v("每个编程语言需自己实现一次，无法通用")]),v._v(" "),_("li",[v._v("故障情况下，所有系统需修改和重启")])])]),v._v(" "),_("li",[v._v("开源方案： 淘宝的TTDL")])])]),v._v(" "),_("li",[v._v("数据库中间件封装： 独立一套系统出来，实现读写分离、分库分表\n"),_("ul",[_("li",[v._v("特点：\n"),_("ul",[_("li",[v._v("通用性强，可以支持多种编程语言")]),v._v(" "),_("li",[v._v("故障情况下，只需修改中间件，无需修改业务系统")]),v._v(" "),_("li",[v._v("中间件性能要求高")])])]),v._v(" "),_("li",[v._v("开源方案： MySQLRouter、Atlas")])])])])])]),v._v(" "),_("h3",{attrs:{id:"关系数据库的问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#关系数据库的问题"}},[v._v("#")]),v._v(" 关系数据库的问题")]),v._v(" "),_("ul",[_("li",[v._v("无法存储数据结构： 需将数据拆分成多个行记录存储")]),v._v(" "),_("li",[v._v("schema扩展不方便： 需要修改表结构")]),v._v(" "),_("li",[v._v("大数据场景IO高： 即使取某一列进行计算，也会读取整行数据")]),v._v(" "),_("li",[v._v("全文搜索功能较弱： like整表扫描匹配，性能较差")])]),v._v(" "),_("h3",{attrs:{id:"nosql"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nosql"}},[v._v("#")]),v._v(" NoSQL")]),v._v(" "),_("p",[v._v("NoSQL（Not Only SQL）通过牺牲一些ACID特性，换取更高的性能和可拓展性。常见四种方案：")]),v._v(" "),_("ul",[_("li",[v._v("K-V存储： 解决关系型数据库无法存储数据结构问题。eg: Redis")]),v._v(" "),_("li",[v._v("文档数据库： 解决关系型数据库schema约束问题。eg: MongoDB")]),v._v(" "),_("li",[v._v("列式数据库： 解决大数据场景IO高问题。eg: HBase")]),v._v(" "),_("li",[v._v("全文搜索引擎： 解决全文搜索功能较弱问题。eg: ElasticSearch")])]),v._v(" "),_("h4",{attrs:{id:"k-v存储"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#k-v存储"}},[v._v("#")]),v._v(" K-V存储")]),v._v(" "),_("p",[v._v("Key是数据的标识，Value是具体的数据。eg: Redis的数组操作LPOP，关系型数据库需执行多次操作（创建编号、查询、删除、更新编号），而NoSQL只需一次操作")]),v._v(" "),_("ul",[_("li",[v._v("特点：\n"),_("ul",[_("li",[v._v("确保隔离性和一致性（I和C），会牺牲原子性和持久性（A和D）\n"),_("ul",[_("li",[v._v("原子性（A）： Redis事务不支持回滚操作，也不会中断后续操作")]),v._v(" "),_("li",[v._v("一致性（C）： Redis事务能保证事务开始之前和结束之后，数据库完整性没有被破坏")]),v._v(" "),_("li",[v._v("隔离性（I）： Redis是单进程单线程的工作模式。如果某一客户端执行大量的命令，会阻塞其他客户端的命令")]),v._v(" "),_("li",[v._v("持久性（D）： Redis支持RDB和AOF两种持久化方式。RDB是定时备份（可能数据还在内存中未写入磁盘），AOF是追加写日志（执行命令后立即写入磁盘，可能丢失1条命令数据）")])])])])])]),v._v(" "),_("h4",{attrs:{id:"文档数据库"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#文档数据库"}},[v._v("#")]),v._v(" 文档数据库")]),v._v(" "),_("p",[v._v("文档数据库的数据以文档的形式存储，文档是一种类似JSON的结构，可以存储不同结构的文档。")]),v._v(" "),_("ul",[_("li",[v._v("特点：\n"),_("ul",[_("li",[v._v("新增字段简单，无需事先执行DDL（Data Definition Language，数据定义语言），可以存储不同结构的文档")]),v._v(" "),_("li",[v._v("不支持事务")]),v._v(" "),_("li",[v._v("不支持join操作")])])])]),v._v(" "),_("h4",{attrs:{id:"列式数据库"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#列式数据库"}},[v._v("#")]),v._v(" 列式数据库")]),v._v(" "),_("p",[v._v("列式数据库将数据按列存储，如果一行数据是1KB，其中需要查询的列只有1B，那么只需读取1B数据。一般用于离线的大数据分析和统计场景")]),v._v(" "),_("ul",[_("li",[v._v("特点：\n"),_("ul",[_("li",[v._v("多个列读取时效率高，因为列存储是按行存储在一起的，只需读取需要的列")]),v._v(" "),_("li",[v._v("多个列写操作时，可能会导致部分列写成功，部分列写失败，导致数据不一致")])])])]),v._v(" "),_("h4",{attrs:{id:"全文搜索引擎"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#全文搜索引擎"}},[v._v("#")]),v._v(" 全文搜索引擎")]),v._v(" "),_("p",[v._v("关系型数据库是根据索引实现快速查询，但是like会会整表扫描，效率低下；全文搜索的条件会随意组合，如果建更多索引会导致索引数量特别多。 全文搜索引擎是通过倒排索引（又称反向索引、置入档案或反向档案）的索引方式，建立单词到文档的索引。")]),v._v(" "),_("h3",{attrs:{id:"缓存的架构设计要点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存的架构设计要点"}},[v._v("#")]),v._v(" 缓存的架构设计要点")]),v._v(" "),_("p",[v._v("单台memcached服务器简单的key-value查询可以达到5w以上的TPS。实现方式是： RDBMS拉数据存储到memcached，首次查询时，memcached没有数据，再去RDBMS查询，然后存储到memcached，下次查询直接从memcached查询。")]),v._v(" "),_("ul",[_("li",[v._v("缓存穿透： 缓存中查不到数据，需要查存储系统，可能是数据不存在，也可能是缓存数据生成需要耗费大量的时间或资源。eg: 爬虫拉取数据\n"),_("ul",[_("li",[v._v("解决方案：\n"),_("ul",[_("li",[v._v("空对象缓存")]),v._v(" "),_("li",[v._v("慢查询场景过滤爬虫，但可能影响SEO和推广")])])])])]),v._v(" "),_("li",[v._v("缓存雪崩： 当缓存失效后，高并发场景下，会有大量请求打到存储系统，可能导致存储系统造成巨大性能压力，进而拖慢整个系统\n"),_("ul",[_("li",[v._v("解决方案：\n"),_("ul",[_("li",[v._v("更新锁： 缓存失效时，加锁，只有一个线程去更新缓存，其他线程要么等待锁释放后重新读缓存，要么直接返回默认值")]),v._v(" "),_("li",[v._v("后台更新： 由后台线程更新缓存，缓存永久有效，后台定时更新缓存。如果内存不足清除后，期间访问返回默认值，后台更新缓存\n"),_("ul",[_("li",[v._v("定时更新策略： 间隔一段时间更新缓存，判断如果缓存过期，立即更新缓存")]),v._v(" "),_("li",[v._v("消息队列策略： 缓存失败时，通过消息队列通知后台更新缓存")])])]),v._v(" "),_("li",[v._v("缓存预热： 系统上线后，直接把数据加载到缓存中，而不是等到请求时再加载")])])])])]),v._v(" "),_("li",[v._v("缓存热点： 热点数据集中在同一份缓存数据，可能导致缓存服务器压力过大\n"),_("ul",[_("li",[v._v("解决方案：\n"),_("ul",[_("li",[v._v("分布式缓存： 将热点数据分散到不同的缓存服务器。 eg: 微博大V每条微博都可以生成100份缓存，分散到100台缓存服务器")])])])])])]),v._v(" "),_("h3",{attrs:{id:"实践-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实践-2"}},[v._v("#")]),v._v(" 实践")]),v._v(" "),_("ul",[_("li",[v._v("在高并发场景下，如果查询接口的qps比较低，可以通过缓存预热的方式，在业务上线前将缓存加载好，缓存的更新机制可通过消息队列监听事件触发时，更新缓存。")])]),v._v(" "),_("h2",{attrs:{id:"第五章-计算高性能"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第五章-计算高性能"}},[v._v("#")]),v._v(" 第五章 计算高性能")]),v._v(" "),_("p",[v._v("主要集中在两方面：")]),v._v(" "),_("ul",[_("li",[v._v("单服务器高性能")]),v._v(" "),_("li",[v._v("服务器集群高性能")]),v._v(" "),_("li",[v._v("编码高性能")])]),v._v(" "),_("h3",{attrs:{id:"单服务器高性能"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#单服务器高性能"}},[v._v("#")]),v._v(" 单服务器高性能")]),v._v(" "),_("h4",{attrs:{id:"网络编程模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#网络编程模型"}},[v._v("#")]),v._v(" 网络编程模型")]),v._v(" "),_("p",[v._v("关键设计在于如何管理和处理请求，与以下模型相关：")]),v._v(" "),_("ul",[_("li",[v._v("I/O模型： 阻塞、非阻塞、同步、异步")]),v._v(" "),_("li",[v._v("进程模型： 单进程、多进程、多线程")])]),v._v(" "),_("h5",{attrs:{id:"ppc模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ppc模型"}},[v._v("#")]),v._v(" PPC模型")]),v._v(" "),_("p",[v._v("PPC(Process Per Connection)模型是一种进程模型，每个连接对应一个进程。优点是简单，缺点是进程切换开销大，进程资源占用大，父子进程通信复杂，不适合高并发场景")]),v._v(" "),_("h5",{attrs:{id:"prefork模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#prefork模型"}},[v._v("#")]),v._v(" prefork模型")]),v._v(" "),_("p",[v._v("prefork模型与PPC模型的区别是，prefork模型是预先fork出多个进程。")]),v._v(" "),_("h5",{attrs:{id:"tpc模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tpc模型"}},[v._v("#")]),v._v(" TPC模型")]),v._v(" "),_("p",[v._v("TPC(Thread Per Connection)模型是一种线程模型，每个连接对应一个线程。优点是线程切换开销小，与进程共享内存，线程通信比PPC模型简单，缺点是可能会导致死锁问题、线程异常的内存越界问题，CPU线程调度和切换开销大，不适合高并发场景")]),v._v(" "),_("h5",{attrs:{id:"prethread模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#prethread模型"}},[v._v("#")]),v._v(" prethread模型")]),v._v(" "),_("p",[v._v("prethread模型与TPC模型的区别是，prethread模型是预先创建多个线程。")]),v._v(" "),_("h5",{attrs:{id:"reactor模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#reactor模型"}},[v._v("#")]),v._v(" Reactor模型")]),v._v(" "),_("p",[v._v("又名Dispatcher模型，是一种I/O模型，主要用于处理高并发的I/O操作。Reactor模型的核心是，当事件发生时，调用事件处理器处理事件。Reactor模型的优点是高并发、高性能。不同编程语言，对应支持的进程、线程、Reactor模型不同。常见以下三种方案：")]),v._v(" "),_("ul",[_("li",[v._v("单Reactor单进程单线程： 没有进程间通信，没有进程竞争，没有锁，性能高。但是，单进程模型下，无法充分利用多核CPU、多线程的优势；")]),v._v(" "),_("li",[v._v("单Reactor单进程多线程： 可以共享进程内存，所以进程间通信简单；但是Reactor承担了所有事件的监听和响应，只在主进程进行，所以可能会成为性能瓶颈；")]),v._v(" "),_("li",[v._v("多Reactor多进程多线程： 主进程负责监听事件，子进程负责处理事件。子进程之间不会有竞争，可以充分利用多核CPU、多线程的优势。例如：Nginx")])]),v._v(" "),_("h5",{attrs:{id:"proactor模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#proactor模型"}},[v._v("#")]),v._v(" Proactor模型")]),v._v(" "),_("p",[v._v("是非阻塞同步网络模型，与Reactor模型的区别是，Reactor模型是同步I/O，Proactor模型是异步I/O。异步处理完了再通知应用程序，适用于高并发场景")]),v._v(" "),_("h4",{attrs:{id:"集群高性能"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#集群高性能"}},[v._v("#")]),v._v(" 集群高性能")]),v._v(" "),_("p",[v._v("通过负载均衡将请求分发到不同机器上。")]),v._v(" "),_("h5",{attrs:{id:"负载均衡分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#负载均衡分类"}},[v._v("#")]),v._v(" 负载均衡分类")]),v._v(" "),_("ul",[_("li",[v._v("DNS负载均衡： 根据不同地理位置，DNS解析到不同IP地址。缺点是更新不及时、拓展性差、无法根据服务器负载情况分配请求")]),v._v(" "),_("li",[v._v("硬件负载均衡： 通过类似基础网络设备做分流，支持多种负载均衡算法。缺点是价格昂贵、维护成本高")]),v._v(" "),_("li",[v._v("软件负载均衡： 如Nginx、LVS。优点是价格低、维护成本低、支持多种负载均衡算法。缺点是性能低于硬件负载均衡")])]),v._v(" "),_("h5",{attrs:{id:"负载均衡架构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#负载均衡架构"}},[v._v("#")]),v._v(" 负载均衡架构")]),v._v(" "),_("p",[v._v("常见组合为：")]),v._v(" "),_("ul",[_("li",[v._v("DNS负载均衡实现地理级别的负载均衡")]),v._v(" "),_("li",[v._v("硬件负载均衡实现集群级别的负载均衡")]),v._v(" "),_("li",[v._v("软件负载均衡实现服务器级别的负载均衡")])]),v._v(" "),_("h5",{attrs:{id:"负载均衡算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#负载均衡算法"}},[v._v("#")]),v._v(" 负载均衡算法")]),v._v(" "),_("p",[v._v("算法分类：")]),v._v(" "),_("ul",[_("li",[v._v("任务平分类： 根据比例、权重均分任务\n"),_("ul",[_("li",[v._v("轮询： 每次请求按顺序分配到不同服务器，不考虑服务器的性能")]),v._v(" "),_("li",[v._v("加权轮询： 每次请求按权重分配到不同服务器")])])]),v._v(" "),_("li",[v._v("负载均衡类： 依据CPU负载、连接数、I/O使用率、网卡吞吐量等来均衡系统的压力\n"),_("ul",[_("li",[v._v("负载最低优先： 每次请求分配到负载最低的服务器，需指定负载计算方式，明确负载计算的时间间隔，如果太短可能早晨频繁波动，太长可能导致负载不均衡。负载计算算法容易成为性能瓶颈。")])])]),v._v(" "),_("li",[v._v("性能最优类： 根据服务器响应速度进行分配\n"),_("ul",[_("li",[v._v("响应速度最快优先： 收集和分析每台服务器每个任务的响应时间，再进行分配。如果采样率过高，则会导致性能消耗较大，采样率过低则会导致结果不准确")])])]),v._v(" "),_("li",[v._v("Hash类： 根据请求的hash值来分配请求\n"),_("ul",[_("li",[v._v("源地址Hash： 同一个源地址分配到同一台服务器上进行处理")]),v._v(" "),_("li",[v._v("ID Hash： 根据请求的ID参数来分配请求")])])])]),v._v(" "),_("h2",{attrs:{id:"第六章-高可用架构模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第六章-高可用架构模式"}},[v._v("#")]),v._v(" 第六章 高可用架构模式")]),v._v(" "),_("h3",{attrs:{id:"cap理论"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cap理论"}},[v._v("#")]),v._v(" CAP理论")]),v._v(" "),_("p",[v._v("强调一致性和可用性的权衡。系统不可能同时满足以下三个特性：")]),v._v(" "),_("ul",[_("li",[v._v("一致性（Consistency）： 客户端读操作能返回最新的写操作结果")]),v._v(" "),_("li",[v._v("可用性（Availability）： 非故障节点在合理的时间里返回合理的响应（不是错误和超时的响应）")]),v._v(" "),_("li",[v._v("分区容错性（Partition Tolerance）： 当出现网络分区(可能是丢包、连接中断、阻塞)后，系统能够继续工作")])]),v._v(" "),_("h4",{attrs:{id:"cap应用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cap应用"}},[v._v("#")]),v._v(" CAP应用")]),v._v(" "),_("p",[v._v("在分布式环境下，因为网络无法做到100%可靠，所以P无法舍弃，所以只能选择CP或AP架构。这里的CP或AP架构是网络分区时，相对侧重C或A。")]),v._v(" "),_("ul",[_("li",[v._v("CP架构： 当网络异常，数据查询时，表现为提示客户端错误")]),v._v(" "),_("li",[v._v("AP架构： 当网络异常，数据查询时，表现为返回旧数据")])]),v._v(" "),_("h3",{attrs:{id:"acid理论"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#acid理论"}},[v._v("#")]),v._v(" ACID理论")]),v._v(" "),_("p",[v._v("强调一致性。数据库为了保证事务的正确性而提出的，一个事务要么全完成，要么全不完成，没有中间态。包含四个约束：")]),v._v(" "),_("ul",[_("li",[v._v("原子性（Atomicity）")]),v._v(" "),_("li",[v._v("一致性（Consistency）： 事务前后数据完整性保持一致")]),v._v(" "),_("li",[v._v("隔离性（Isolation）： 事务之间互不干扰")]),v._v(" "),_("li",[v._v("持久性（Durability）： 事务一旦提交，数据就会永久保存")])]),v._v(" "),_("h3",{attrs:{id:"base理论"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#base理论"}},[v._v("#")]),v._v(" BASE理论")]),v._v(" "),_("p",[v._v("强调可用性。是CAP理论中AP方案的延伸，是为了解决分布式系统的一致性问题。BASE是指：")]),v._v(" "),_("ul",[_("li",[v._v("基本可用（Basically Available）： 分布式系统故障时，允许损失部分可用性，保证核心功能可用")]),v._v(" "),_("li",[v._v("软状态（Soft State）： 允许系统中存在中间状态，不同节点数据可能不一致")]),v._v(" "),_("li",[v._v("最终一致性（Eventually Consistent）： 系统中的所有数据副本经过一定时间后，最终能够达到一致状态")])]),v._v(" "),_("h2",{attrs:{id:"第七章-故障模式与影响分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第七章-故障模式与影响分析"}},[v._v("#")]),v._v(" 第七章 故障模式与影响分析")]),v._v(" "),_("p",[v._v("FMEA（Failure Mode and Effect Analysis）是一种系统性的、有方法的分析方法，用于识别和评估系统中的潜在故障模式及其影响，从而提高系统的可靠性。")]),v._v(" "),_("h3",{attrs:{id:"fmea方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#fmea方法"}},[v._v("#")]),v._v(" FMEA方法")]),v._v(" "),_("p",[v._v("FMEA分析表应包含以下内容：")]),v._v(" "),_("ul",[_("li",[v._v("功能点： 业务层面划分的功能，非技术层面")]),v._v(" "),_("li",[v._v("故障模式： 系统可能出现的故障点和故障形式，eg: MySQL响应达3s")]),v._v(" "),_("li",[v._v("故障影响： 当发生故障模式中的故障时，功能点会有什么影响，eg: 20%用户无法访问")]),v._v(" "),_("li",[v._v("严重程度： 根据功能点重要程度、故障影响范围、功能点受损程度判断，高中低分级")]),v._v(" "),_("li",[v._v("故障原因")]),v._v(" "),_("li",[v._v("故障概率： 可重点按硬件、开源系统、自研系统维度评估，预留资源投入，高中低分级")]),v._v(" "),_("li",[v._v("风险程度： 根据严重程度和故障概率评估，高中低分级")]),v._v(" "),_("li",[v._v("已有措施： 针对故障原因，系统是否提供了对呀措施应对 eg: 告警、容错、自恢复")]),v._v(" "),_("li",[v._v("规避措施： 降低故障发生概率而做的事，可以是技术或管理手段 eg: 冗余、定时重启")]),v._v(" "),_("li",[v._v("解决措施： 为了解决问题而做的事，如果某个故障既可以规避又可以解决，通常优先采用解决措施")]),v._v(" "),_("li",[v._v("后续规划： 综合前面的分析，检查哪些故障缺乏对应措施和不足，按优先级排序针对性优化")])]),v._v(" "),_("h2",{attrs:{id:"第八章-存储高可用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第八章-存储高可用"}},[v._v("#")]),v._v(" 第八章 存储高可用")]),v._v(" "),_("p",[v._v("通过将数据复制到多个设备，以数据冗余的方式提高数据的可用性，主要的复杂性再如何应对复制延迟和中断导致的数据不一致问题，通常需思考以下问题：")]),v._v(" "),_("ul",[_("li",[v._v("数据如何复制")]),v._v(" "),_("li",[v._v("各节点职责是什么")]),v._v(" "),_("li",[v._v("如何应对复制延迟")]),v._v(" "),_("li",[v._v("如何应对复制中断")])]),v._v(" "),_("h3",{attrs:{id:"主备复制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#主备复制"}},[v._v("#")]),v._v(" 主备复制")]),v._v(" "),_("p",[_("img",{attrs:{src:a(391),alt:"alt text"}})]),v._v(" "),_("p",[v._v("详细设计：")]),v._v(" "),_("ul",[_("li",[v._v("主机存储数据，复制到备机")]),v._v(" "),_("li",[v._v("正常情况下，读写在主机上进行，备机不对外提供读写服务")]),v._v(" "),_("li",[v._v("主机故障情况下，且主机短时间内不能自动恢复（eg:硬盘损坏），则人工将备机主动升级为主机")]),v._v(" "),_("li",[v._v("主机不能恢复，写入主机但还没备份到备机的数据会丢失，需要人工排查和恢复，数据可能丢失，业务需考虑该风险应对方案")]),v._v(" "),_("li",[v._v("如果复制延迟了，主机又宕机了，可能会丢失较多数据，需要监控复制延迟情况，延迟较多需告警")])]),v._v(" "),_("p",[v._v("优点：")]),v._v(" "),_("ul",[_("li",[v._v("主备切换时无感知")]),v._v(" "),_("li",[v._v("主备双方只需要数据传输，无复杂操作")])]),v._v(" "),_("p",[v._v("缺点：")]),v._v(" "),_("ul",[_("li",[v._v("备机只用作备份用途，没有读写操作，硬件成本浪费")]),v._v(" "),_("li",[v._v("故障需要人工干预，无法自动恢复")])]),v._v(" "),_("h3",{attrs:{id:"主从复制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#主从复制"}},[v._v("#")]),v._v(" 主从复制")]),v._v(" "),_("p",[_("img",{attrs:{src:a(392),alt:"alt text"}})]),v._v(" "),_("p",[v._v("相比主备复制方案，差异点是：")]),v._v(" "),_("ul",[_("li",[v._v("写操作发送到主机，读操作发送到主机或从机，算法可以是随机或者轮询读等")]),v._v(" "),_("li",[v._v("主机故障时，无法写入，但不影响读操作")])]),v._v(" "),_("h3",{attrs:{id:"主备倒换和主从倒换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#主备倒换和主从倒换"}},[v._v("#")]),v._v(" 主备倒换和主从倒换")]),v._v(" "),_("p",[v._v("主要解决主备复制和主从复制的以下问题：")]),v._v(" "),_("ul",[_("li",[v._v("主机故障后，无法进行写操作")]),v._v(" "),_("li",[v._v("如果主机无法恢复，需要指定新的主机角色")])]),v._v(" "),_("p",[v._v("详细设计：")]),v._v(" "),_("ul",[_("li",[v._v("主备间状态判断： 状态传递的渠道和状态检测的内容\n"),_("ul",[_("li",[v._v("状态传递的渠道： 是相互连接还是第三方仲裁？")]),v._v(" "),_("li",[v._v("状态检测的内容： eg: 机器是否掉电，进程是否存在等")])])]),v._v(" "),_("li",[v._v("倒换决策：\n"),_("ul",[_("li",[v._v("倒换时机： 明确什么情况下切换主机 eg: 进程不存在，主机响应超2s，3分钟内连续重启3次等")]),v._v(" "),_("li",[v._v("倒换策略： 明确主机恢复后，应该成为备机还是主机")]),v._v(" "),_("li",[v._v("自动程度： 全自动还是半自动 eg: 人工切换主机")])])]),v._v(" "),_("li",[v._v("数据冲突解决： 主备切换后，旧主机的新数据未备份到新主机，可能导致数据不一致")])]),v._v(" "),_("h4",{attrs:{id:"常见架构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见架构"}},[v._v("#")]),v._v(" 常见架构")]),v._v(" "),_("h5",{attrs:{id:"互连式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#互连式"}},[v._v("#")]),v._v(" 互连式")]),v._v(" "),_("p",[_("img",{attrs:{src:a(393),alt:"alt text"}})]),v._v(" "),_("ul",[_("li",[v._v("主机发送状态给备机，或者备机主动获取主机状态")]),v._v(" "),_("li",[v._v("主备机器通过网络+串口通道连接，进行状态传递通信")]),v._v(" "),_("li",[v._v("如果状态传递的通道出现异常（eg:网线拔了），可能导致备机误以为主机宕机，升级为主机\n"),_("ul",[_("li",[v._v("可通过增加更多通道增强传递可靠性，但是只是降低了出现概率，无法完全避免")])])])]),v._v(" "),_("h5",{attrs:{id:"中介式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#中介式"}},[v._v("#")]),v._v(" 中介式")]),v._v(" "),_("p",[_("img",{attrs:{src:a(394),alt:"alt text"}})]),v._v(" "),_("ul",[_("li",[v._v("主备设备连接到中介设备，中介设备负责主备设备的状态传递和切换")]),v._v(" "),_("li",[v._v("代价就是实现中介设备的高可用")]),v._v(" "),_("li",[v._v("可使用开源成熟方案 eg: Zookeeper")])]),v._v(" "),_("h5",{attrs:{id:"模拟式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模拟式"}},[v._v("#")]),v._v(" 模拟式")]),v._v(" "),_("p",[_("img",{attrs:{src:a(395),alt:"alt text"}})]),v._v(" "),_("ul",[_("li",[v._v("通过模拟读写操作来探测主机状态，如果主机无法响应，备机升级为主机")])]),v._v(" "),_("h3",{attrs:{id:"主主复制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#主主复制"}},[v._v("#")]),v._v(" 主主复制")]),v._v(" "),_("p",[_("img",{attrs:{src:a(396),alt:"alt text"}})]),v._v(" "),_("ul",[_("li",[v._v("两台机器都是主机，通过互相将数据复制给对方，客户端客挑选任意机器进行写操作")]),v._v(" "),_("li",[v._v("详细设计与主备复制相似，但不存在主备倒换概念")]),v._v(" "),_("li",[v._v("需保障数据能够双向复制，数据在大多数情况下不允许双向复制 eg: 插入记录id自增、库存扣减")]),v._v(" "),_("li",[v._v("适用于临时性、可丢失、可覆盖的数据场景")])]),v._v(" "),_("h3",{attrs:{id:"数据集群"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据集群"}},[v._v("#")]),v._v(" 数据集群")]),v._v(" "),_("p",[v._v("单机运算能力有限，集群处理存储和处理问题")]),v._v(" "),_("h4",{attrs:{id:"数据集中集群"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据集中集群"}},[v._v("#")]),v._v(" 数据集中集群")]),v._v(" "),_("ul",[_("li",[v._v("类似主备、主从架构，主机读写，从机只读")]),v._v(" "),_("li",[v._v("由于服务器数量更多，会出现多条复制通道、主机状态检测的性能问题，主机选举决策问题")])]),v._v(" "),_("h4",{attrs:{id:"数据分散集群"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据分散集群"}},[v._v("#")]),v._v(" 数据分散集群")]),v._v(" "),_("p",[_("img",{attrs:{src:a(397),alt:"alt text"}})]),v._v(" "),_("ul",[_("li",[v._v("无主从概念，每台机器都是主机，数据分散存储在多台机器上")]),v._v(" "),_("li",[v._v("要有一个角色执行数据分配算法，可以是独立的也可以是选举出来的服务器")]),v._v(" "),_("li",[v._v("设计上需通过算法保障均衡性，避免数据倾斜；需考虑容错性，服务器故障时分区数据需分配到其他服务器；需考虑可伸缩性，扩容时需自动将数据迁移到新服务器")])]),v._v(" "),_("h4",{attrs:{id:"分布式事务算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务算法"}},[v._v("#")]),v._v(" 分布式事务算法")]),v._v(" "),_("p",[v._v("数据的一致性可采用事务实现，在集群中该数据分布在不同节点上，节点间只能通过消息通信，所以事务依赖消息通知实现。但消息可能丢失，所以存在分布式事务算法")]),v._v(" "),_("ul",[_("li",[v._v("两阶段提交(2PC: Two-phase commit protocol)： 通过协调者和参与者两个角色，协调者发起事务，参与者执行事务，协调者发起提交，参与者执行提交。\n"),_("ul",[_("li",[v._v("缺点:\n"),_("ul",[_("li",[v._v("同步阻塞： 协调者和参与者需等待对方响应的消息，过程中节点处于阻塞状态，可能导致阻塞")]),v._v(" "),_("li",[v._v("状态不一致： 部分参与者未收到提交消息，超时直接ROLLBACK了")]),v._v(" "),_("li",[v._v("单点故障： 协调者故障，整个事务无法进行，参与者一直等待")])])])])]),v._v(" "),_("li",[v._v("三阶段提交(3PC: Three-phase commit protocol)： 在两阶段提交基础上，增加了超时机制，防止参与者长时间阻塞")])]),v._v(" "),_("h4",{attrs:{id:"分布式一致性算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分布式一致性算法"}},[v._v("#")]),v._v(" 分布式一致性算法")]),v._v(" "),_("p",[v._v("确保分散在多个节点的数据的一致性，以满足CP架构要求")]),v._v(" "),_("h5",{attrs:{id:"复制状态机技术"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#复制状态机技术"}},[v._v("#")]),v._v(" 复制状态机技术")]),v._v(" "),_("p",[v._v("常用的算法有： Paxos（最权威）、Raft、Zab")]),v._v(" "),_("p",[v._v("主要角色：")]),v._v(" "),_("ul",[_("li",[v._v("副本： 每个节点都有一份完整状态机副本")]),v._v(" "),_("li",[v._v("状态机： 接受输入和执行操作，流转状态")]),v._v(" "),_("li",[v._v("算法： 协调各副本处理逻辑，保证数据一致性")])]),v._v(" "),_("h3",{attrs:{id:"数据分区"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据分区"}},[v._v("#")]),v._v(" 数据分区")]),v._v(" "),_("p",[v._v("基于地理级别的故障设计高可用架构，一个良好的设计需考虑多个方面：")]),v._v(" "),_("ul",[_("li",[v._v("数据量： 如果只是水平扩容，可能导致较高的运维成本；")]),v._v(" "),_("li",[v._v("分区规则： 可按洲际、国家、城市分区，主要考虑业务范围和成本因素等；")]),v._v(" "),_("li",[v._v("复制规则： 部分数据如果受影响，整体数据不会受影响，但需考虑恢复损坏或丢失的这部分数据，所以需要复制方案，常见以下备份架构\n"),_("ul",[_("li",[v._v("集中式： 多地区数据集中备份到一个地区，特点是成本高，易扩展，简单")]),v._v(" "),_("li",[v._v("互备式： 每个分区备份另一个分区的数据，特点是成本低，但是复杂度高，拓展时要考虑备份方向，不易扩展")]),v._v(" "),_("li",[v._v("独立式： 每个分区都有自己独立的备份中心，特点是成本高（比集中式高，不同的场地成本），易拓展，简单")])])])]),v._v(" "),_("h2",{attrs:{id:"第九章-计算高可用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第九章-计算高可用"}},[v._v("#")]),v._v(" 第九章 计算高可用")]),v._v(" "),_("p",[v._v("当部分硬件损坏时，计算任务可正常运行，通过冗余更多服务器达到计算高可用。复杂度主要在于任务管理上，如何在任务失败时重新分配到新服务器执行。")]),v._v(" "),_("h3",{attrs:{id:"主备架构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#主备架构"}},[v._v("#")]),v._v(" 主备架构")]),v._v(" "),_("p",[_("img",{attrs:{src:a(398),alt:"alt text"}})]),v._v(" "),_("p",[v._v("类似于存储高可用的主备架构，主要分为冷备和温备架构。")]),v._v(" "),_("ul",[_("li",[v._v("冷备： 程序和配置文件都准备好，但是不运行，需要手动启动。优点是节约资源")]),v._v(" "),_("li",[v._v("温备： 程序和配置文件都准备好，且运行，但是不对外提供服务，需将任务分配器的任务请求切换为备机即可。优点是减少手工操作")])]),v._v(" "),_("h3",{attrs:{id:"主从架构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#主从架构"}},[v._v("#")]),v._v(" 主从架构")]),v._v(" "),_("p",[_("img",{attrs:{src:a(399),alt:"alt text"}})]),v._v(" "),_("p",[v._v("主机和从机都对外提供服务，主机负责写操作，从机负责读操作。主机故障时，从机升级为主机。")]),v._v(" "),_("h3",{attrs:{id:"对称集群"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对称集群"}},[v._v("#")]),v._v(" 对称集群")]),v._v(" "),_("p",[_("img",{attrs:{src:a(400),alt:"alt text"}})]),v._v(" "),_("p",[v._v("任务分配器检查服务状态，并分配任务到多台服务器上，每台服务器都可以执行任务。")]),v._v(" "),_("ul",[_("li",[v._v("任务分配： 常用轮询和随机算法；")]),v._v(" "),_("li",[v._v("状态检测： 服务器状态（宕机、网络是否正常等）、任务状态（是否执行成功等）、心跳检测（是否正常运行）；")])]),v._v(" "),_("h4",{attrs:{id:"非对称集群"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#非对称集群"}},[v._v("#")]),v._v(" 非对称集群")]),v._v(" "),_("p",[_("img",{attrs:{src:a(401),alt:"alt text"}})]),v._v(" "),_("p",[v._v("不同角色的服务器承担不同的职责，如任务分配器、任务执行器、任务监控器等。")]),v._v(" "),_("h2",{attrs:{id:"第十章-业务高可用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第十章-业务高可用"}},[v._v("#")]),v._v(" 第十章 业务高可用")]),v._v(" "),_("h3",{attrs:{id:"异地多活"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#异地多活"}},[v._v("#")]),v._v(" 异地多活")]),v._v(" "),_("p",[v._v("如果业务规模很大，业务系统中断会带来很大影响，那么就需要对业务做异地多活架构，避免单点故障。异地多活架构分为以下几种：")]),v._v(" "),_("ul",[_("li",[v._v("同城异区： 部署在同一个城市不同市区的多个机房。从复杂度、成本、故障发生概率综合考虑，是最优选择")]),v._v(" "),_("li",[v._v("跨城异地： 部署在不同城市的多个机房。由于距离较远，数据传输时不可控因素会非常多，可能导致数据不一致问题")]),v._v(" "),_("li",[v._v("跨国异地： 部署在不同国家的多个机房。由于跨国，可能会受到政策、网络等因素影响，延时可能达好几秒。主要应用场景有：\n"),_("ul",[_("li",[v._v("为不同地区提供服务，eg: 亚马逊中国和亚马逊美国帐号不互通")]),v._v(" "),_("li",[v._v("只读类业务做多活")])])])]),v._v(" "),_("h4",{attrs:{id:"关键设计"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#关键设计"}},[v._v("#")]),v._v(" 关键设计")]),v._v(" "),_("ul",[_("li",[v._v("关键业务做多活： 并非所有业务都适合做多活 eg: 注册和登录，确保登录多活，注册单活，避免数据一致性问题")]),v._v(" "),_("li",[v._v("核心数据一致：\n"),_("ul",[_("li",[v._v("减少异地距离，搭建高速网络；")]),v._v(" "),_("li",[v._v("尽量减少数据同步，只同步核心业务数据；")]),v._v(" "),_("li",[v._v("保障最终一致性，不保证实时一致性；")])])]),v._v(" "),_("li",[v._v("采用多种数据同步手段：\n"),_("ul",[_("li",[v._v("消息队列同步；")]),v._v(" "),_("li",[v._v("二次读取数据（请求重试）；")]),v._v(" "),_("li",[v._v("存储系统主从复制；")]),v._v(" "),_("li",[v._v("根据sessionId回源读取；")]),v._v(" "),_("li",[v._v("回源失败，重新生成数据；")])])]),v._v(" "),_("li",[v._v("只保证绝大部分用户的异地多活：\n"),_("ul",[_("li",[v._v("将实时操作改为异步操作，eg: 转账拆分成转账申请和转账操作，转账申请异地多活，转账操作单活；")]),v._v(" "),_("li",[v._v("不可用情况下，通过一些措施安抚用户； eg: 挂公告、事后补偿、事后通知等；")])])])]),v._v(" "),_("h4",{attrs:{id:"设计步骤"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计步骤"}},[v._v("#")]),v._v(" 设计步骤")]),v._v(" "),_("ol",[_("li",[v._v("业务分级： 挑选核心业务、访问量大、产生大量收入进行多活")]),v._v(" "),_("li",[v._v("数据分类：")])]),v._v(" "),_("ul",[_("li",[v._v("数据量级")]),v._v(" "),_("li",[v._v("唯一性要求： 避免多机生成唯一id不一致")]),v._v(" "),_("li",[v._v("实时性要求： 实时性要多高")]),v._v(" "),_("li",[v._v("可丢失性： 是否允许数据丢失")]),v._v(" "),_("li",[v._v("可恢复性： 是否可恢复、重置、重复生成（eg:重登）")])]),v._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[v._v("数据同步： 选择合适的同步方案，存储系统同同步、消息队列同步、重复生成策略")]),v._v(" "),_("li",[v._v("异常处理：")])]),v._v(" "),_("ul",[_("li",[v._v("目的： 问题发生时，减少影响范围；问题修复后，修正异常数据；补充用户损失")]),v._v(" "),_("li",[v._v("方案：\n"),_("ul",[_("li",[v._v("多通道同步： 同时使用MySQL主从同步和消息队列同步。")]),v._v(" "),_("li",[v._v("日志记录： 服务器存储一份日志，数据库存储一份，避免数据库宕机丢失日志")]),v._v(" "),_("li",[v._v("用户补偿")])])])]),v._v(" "),_("h3",{attrs:{id:"接口故障"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口故障"}},[v._v("#")]),v._v(" 接口故障")]),v._v(" "),_("p",[v._v("原因分为内部和外部原因，可能是程序死循环、慢查询、黑客攻击等等，应对措施有：")]),v._v(" "),_("ul",[_("li",[v._v("降级： 通过系统后门降级、独立降级系统，以禁用部分功能，保障其他功能")]),v._v(" "),_("li",[v._v("熔断： 通过熔断器，当接口调用失败率达到一定阈值，自动熔断，避免雪崩")]),v._v(" "),_("li",[v._v("限流： 通过限流器，限制接口调用频率，避免雪崩\n"),_("ul",[_("li",[v._v("基于请求限流： 限制某个指标的累积上限")]),v._v(" "),_("li",[v._v("基于资源限流： 限制某个资源的累积上限")])])]),v._v(" "),_("li",[v._v("排队： 通过消息队列，将请求排队，避免瞬间高并发")])]),v._v(" "),_("h2",{attrs:{id:"第十一章-可拓展模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第十一章-可拓展模式"}},[v._v("#")]),v._v(" 第十一章 可拓展模式")]),v._v(" "),_("p",[v._v("通过拆分模块，拓展时仅需修改某一部分即可，无需到处修改")]),v._v(" "),_("h3",{attrs:{id:"可拓展的基本思想"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#可拓展的基本思想"}},[v._v("#")]),v._v(" 可拓展的基本思想")]),v._v(" "),_("p",[v._v("拆分思路：")]),v._v(" "),_("ul",[_("li",[v._v("面向流程拆分")]),v._v(" "),_("li",[v._v("面向服务拆分")]),v._v(" "),_("li",[v._v("面向功能拆分")])])])}),[],!1,null,null,null);_.default=i.exports}}]);