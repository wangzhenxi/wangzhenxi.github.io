(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{497:function(t,v,_){"use strict";_.r(v);var e=_(19),d=Object(e.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"redis实战"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis实战"}},[t._v("#")]),t._v(" Redis实战")]),t._v(" "),v("h2",{attrs:{id:"名词"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#名词"}},[t._v("#")]),t._v(" 名词")]),t._v(" "),v("ul",[v("li",[t._v("ACID： atomicity原子性、consistency一致性、isolation隔离性、durability耐久性，一个数据库实现可靠的数据事务需满足的性质。")])]),t._v(" "),v("h2",{attrs:{id:"特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),v("ul",[v("li",[t._v("速度快： 使用内存存储的非关系型数据库。")]),t._v(" "),v("li",[t._v("原子性： 当命令正在读取或修改数据的时候，其他客户端不能读取或修改相同的数据。")])]),t._v(" "),v("h2",{attrs:{id:"数据类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[t._v("#")]),t._v(" 数据类型")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("结构类型")]),t._v(" "),v("th",[t._v("结构存储的值")]),t._v(" "),v("th",[t._v("场景")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("STRING")]),t._v(" "),v("td",[t._v("字符串、浮点数、整数")]),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("LIST")]),t._v(" "),v("td",[t._v("一个链表")]),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("SET")]),t._v(" "),v("td",[t._v("无序去重的集合")]),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("HASH")]),t._v(" "),v("td",[t._v("包含键值对的无序散列表")]),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("ZSET")]),t._v(" "),v("td",[t._v("根据分值大小排序且去重的有序映射")]),t._v(" "),v("td",[t._v("排行榜(分值越小，排行靠前)")])])])]),t._v(" "),v("h3",{attrs:{id:"指令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#指令"}},[t._v("#")]),t._v(" 指令")]),t._v(" "),v("h4",{attrs:{id:"setring-字符串"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#setring-字符串"}},[t._v("#")]),t._v(" SETRING 字符串")]),t._v(" "),v("ul",[v("li",[t._v("GET")]),t._v(" "),v("li",[t._v("SET")]),t._v(" "),v("li",[t._v("DEL")])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("指令")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[v("code",[t._v("APPEND key value")])]),t._v(" "),v("td",[t._v("将值追加到字符串尾部")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("GETRANGE key value")])]),t._v(" "),v("td",[t._v("将值追加到字符串尾部")])])])]),t._v(" "),v("h4",{attrs:{id:"list-列表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#list-列表"}},[t._v("#")]),t._v(" LIST 列表")]),t._v(" "),v("p",[t._v("redis使用双链表表示列表")]),t._v(" "),v("ul",[v("li",[t._v("RPUSH")]),t._v(" "),v("li",[t._v("LPUSH")]),t._v(" "),v("li",[t._v("LRANGE")]),t._v(" "),v("li",[t._v("LINDEX 获取给定位置的元素")])]),t._v(" "),v("h4",{attrs:{id:"set-集合"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#set-集合"}},[t._v("#")]),t._v(" SET 集合")]),t._v(" "),v("p",[t._v("redis通过配置可设置集合使用整数集合表示的限制条件，超出限制则使用散列表表示。")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("指令")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[v("code",[t._v("SADD key item1 [item2 ...]")])]),t._v(" "),v("td",[t._v("增加一个或多个元素")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("SMEMBERS key")])]),t._v(" "),v("td",[t._v("返回集合包含的所有元素")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("SISMEMBER key item")])]),t._v(" "),v("td",[t._v("是否在集合中")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("SREM key item")])]),t._v(" "),v("td",[t._v("移除元素")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("SCARD key")])]),t._v(" "),v("td",[t._v("返回集合包含元素数量")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("SRANDMEMBER key [count]")])]),t._v(" "),v("td",[t._v("随机返回count个元素，整数不重复，负数会重复")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("SPOP key")])]),t._v(" "),v("td",[t._v("随机移除一个元素")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("SMOVE source-key dest-key item")])]),t._v(" "),v("td",[t._v("将item从source-key集合中移除，并移入dest-key的集合下")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("SDIFF key1 [key2 ...]")])]),t._v(" "),v("td",[t._v("返回存在于key1，不存在于其他集合的元素(差集)")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("SDIFFSTORE dest-key key1 [key2 ...]")])]),t._v(" "),v("td",[t._v("将存在于key1，不存在于其他集合的元素，存储到dest-key去(差集)")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("SINTER key1 [key2 ...]")])]),t._v(" "),v("td",[t._v("返回同时存在于所有集合的元素(交集)")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("SINTERSTORE dest-key key1 [key2 ...]")])]),t._v(" "),v("td",[t._v("返回同时存在于所有集合的元素,存储到dest-key去(交集)")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("SUNION key1 [key2 ...]")])]),t._v(" "),v("td",[t._v("返回那些至少存在于一个集合中的元素(并集)")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("SUNIONSTORE dest-key key1 [key2 ...]")])]),t._v(" "),v("td",[t._v("返回那些至少存在于一个集合中的元素,存储到dest-key去(并集)")])])])]),t._v(" "),v("h4",{attrs:{id:"hash-散列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hash-散列"}},[t._v("#")]),t._v(" HASH 散列")]),t._v(" "),v("p",[t._v("redis使用散列表表示散列")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("指令")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[v("code",[t._v("HSET key field1 value1 [field2 value2]")])]),t._v(" "),v("td",[t._v("为散列里面的一个或多个键设置值")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("HGET key field")])]),t._v(" "),v("td",[t._v("从散列里获取键的值")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("HMGET key field1 [field2]")])]),t._v(" "),v("td",[t._v("从散列里获取键的值")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("HDEL key field1 [field2]")])]),t._v(" "),v("td",[t._v("移除散列一个或多个键值对")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("HLEN key")])]),t._v(" "),v("td",[t._v("获取散列键值对数量")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("HEXISTS key filed")])]),t._v(" "),v("td",[t._v("检查给定键是否存在于散列中")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("HKEYS key")])]),t._v(" "),v("td",[t._v("获取散列包含的所有键")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("HVALS key")])]),t._v(" "),v("td",[t._v("获取散列包含的所有值")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("HGETALL key")])]),t._v(" "),v("td",[t._v("获取散列所有键值")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("HINCRBY key field increment")])]),t._v(" "),v("td",[t._v("给散列指定键的值加上整数increment")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("HINCRBYFLOAT key filed increment")])]),t._v(" "),v("td",[t._v("给散列指定键的值加上浮点数increment")])])])]),t._v(" "),v("h4",{attrs:{id:"zset-有序集合"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#zset-有序集合"}},[t._v("#")]),t._v(" ZSET 有序集合")]),t._v(" "),v("p",[t._v("redis通过散列表加上跳跃表表示有序集合")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("指令")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[v("code",[t._v("ZADD key score member [score2 member2 ...]")])]),t._v(" "),v("td",[t._v("将带有一定分值的成员添加到有序集合")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("ZREM key member1 [member2 ...]")])]),t._v(" "),v("td",[t._v("移除成员")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("ZCARD key")])]),t._v(" "),v("td",[t._v("返回有序集合成员数量")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("ZINCRBY key increment member")])]),t._v(" "),v("td",[t._v("将member成员的分值加上increment")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("ZCOUNT key min max")])]),t._v(" "),v("td",[t._v("返回分值介于min和max之间的成员数量")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("ZSCORE key member")])]),t._v(" "),v("td",[t._v("返回成员member的分值")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("ZRANK key member")])]),t._v(" "),v("td",[t._v("分值升序排序，返回成员member在有序集合之中的排名")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("ZRANGE key start stop [WITHSCORES]")])]),t._v(" "),v("td",[t._v("分值升序排序，返回排名介于start和stop之间的成员，如果给了WITHSCORES参数，则将成员分值一并返回")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("ZREVRANK key member")])]),t._v(" "),v("td",[t._v("分值升序排序，返回成员member在有序集合之中的排名")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("ZREVRANGE key start stop [WITHSCORES]")])]),t._v(" "),v("td",[t._v("分值降序排序，返回排名介于start和stop之间的成员，如果给了WITHSCORES参数，则将成员分值一并返回")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]")])]),t._v(" "),v("td",[t._v("分值升序排序，返回分值介于min和max之间的成员，如果给了WITHSCORES参数，则将成员分值一并返回")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]")])]),t._v(" "),v("td",[t._v("分值降序排序，返回分值介于max和min之间的成员，如果给了WITHSCORES参数，则将成员分值一并返回")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("ZREMRANGEBYSRANK key start stop")])]),t._v(" "),v("td",[t._v("分值升序排序，移除排名介于start和stop之间的成员")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("ZREMRANGEBYSCORE key min max")])]),t._v(" "),v("td",[t._v("分值升序排序，移除排名介于min和max之间的成员")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("ZINTERSTORE dest-key key-count key1 [key2 ...] [WEIGHTS weight1 [weight2]] [AGGREGATE SUM|MIN|MAX]")])]),t._v(" "),v("td",[t._v("有序集合交集运算")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("ZUNIONSTORE dest-key key-count key1 [key2 ...] [WEIGHTS weight1 [weight2]] [AGGREGATE SUM|MIN|MAX]")])]),t._v(" "),v("td",[t._v("有序集合并集运算")])])])]),t._v(" "),v("h4",{attrs:{id:"其他命令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#其他命令"}},[t._v("#")]),t._v(" 其他命令")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("指令")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[v("code",[t._v("SORT key [BY pattern] [LIMIT offset count] [GET pattern] [ASC|DESC] [ALPHA] destination")])]),t._v(" "),v("td",[t._v("排序")])])])]),t._v(" "),v("h5",{attrs:{id:"发布与订阅"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#发布与订阅"}},[t._v("#")]),t._v(" 发布与订阅")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("指令")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[v("code",[t._v("SUBSCRIBE channel [channel]")])]),t._v(" "),v("td",[t._v("订阅给定一个或多个频道")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("UNSUBSCRIBE [channel... [channel2 ...]]")])]),t._v(" "),v("td",[t._v("退订给定一个或多个频道，没有给定则退订所有频道")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("PUBLISH channel message")])]),t._v(" "),v("td",[t._v("向给定频道发送消息")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("PSUBSCRIBE pattern1 [pattern2 ...]")])]),t._v(" "),v("td",[t._v("订阅与给定模式匹配的所有频道")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("PUNSUBSCRIBE pattern1 [pattern2 ...]")])]),t._v(" "),v("td",[t._v("退订给定模式匹配的所有坡；频道，没有给定则退订所有频道")])])])]),t._v(" "),v("h5",{attrs:{id:"事务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[t._v("#")]),t._v(" 事务")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("指令")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[v("code",[t._v("MULTI")])]),t._v(" "),v("td",[t._v("事务开始")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("EXEC")])]),t._v(" "),v("td",[t._v("执行事务开始后的多个指令")])])])]),t._v(" "),v("h5",{attrs:{id:"过期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#过期"}},[t._v("#")]),t._v(" 过期")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("指令")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[v("code",[t._v("PERSIST key")])]),t._v(" "),v("td",[t._v("移除键的过期时间(s)")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("TTL key")])]),t._v(" "),v("td",[t._v("查看键距离过期剩余时间(s)")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("EXPIRE key seconds")])]),t._v(" "),v("td",[t._v("给定键在指定秒数后过期")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("EXPIREAT key timestamp")])]),t._v(" "),v("td",[t._v("给定键在给定UNIX时间戳(s)后过期")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("PTTL key")])]),t._v(" "),v("td",[t._v("查看键距离过期剩余时间(ms)")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("PEXPIRE key milliseconds")])]),t._v(" "),v("td",[t._v("给定键在指定毫秒数后过期")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("PEXPIREAT key timestamp-milliseconds")])]),t._v(" "),v("td",[t._v("给定键在给定UNIX时间戳(ms)后过期")])])])]),t._v(" "),v("h2",{attrs:{id:"数据持久化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据持久化"}},[t._v("#")]),t._v(" 数据持久化")]),t._v(" "),v("h3",{attrs:{id:"方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[t._v("#")]),t._v(" 方法")]),t._v(" "),v("ul",[v("li",[t._v("快照: 把某一时刻所有数据写入硬盘")]),t._v(" "),v("li",[t._v("AOF: append-only file，在执行命令时，将被执行的命令写入硬盘")])]),t._v(" "),v("h3",{attrs:{id:"指令-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#指令-2"}},[t._v("#")]),t._v(" 指令")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("指令")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("BGSAVE")]),t._v(" "),v("td",[t._v("创建一个快照。通过fork一个子进程，负责将快照写入硬盘，而父进程继续处理命令。缺点： 速度慢，内存占用大")])]),t._v(" "),v("tr",[v("td",[t._v("SAVE")]),t._v(" "),v("td",[t._v("创建一个快照。在快照创建完毕前不再响应任何其他指令 。缺点：无法正常执行其他指令")])]),t._v(" "),v("tr",[v("td",[t._v("SHUTDOWN")]),t._v(" "),v("td",[t._v("执行SAVE后关闭服务器")])]),t._v(" "),v("tr",[v("td",[t._v("BGREWRITEAOF")]),t._v(" "),v("td",[t._v("移除AOF文件中冗余命令来重写AOF文件，从而减小AOF文件体积，工作原理同"),v("code",[t._v("BGSAVE")])])]),t._v(" "),v("tr",[v("td",[t._v("INFO")]),t._v(" "),v("td",[t._v("查看服务器当前状态有关信息，如内存占用量、客户端连接数、上次快照后执行的命令数量等，其中"),v("code",[t._v("aof_pending_bio_fsync")]),t._v("为0时，表示服务器将所有数据已持久化到硬盘了")])])])]),t._v(" "),v("h2",{attrs:{id:"实践"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实践"}},[t._v("#")]),t._v(" 实践")]),t._v(" "),v("h3",{attrs:{id:"分布式锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[t._v("#")]),t._v(" 分布式锁")]),t._v(" "),v("p",[t._v("用于解决能够被不同客户端多个进程访问的共享内存数据结构。在数据进行"),v("code",[t._v("加锁")]),t._v("时，程序需通过获取锁来对数据进行"),v("code",[t._v("排他性访问")]),t._v("的能力，才能对数据进行操作，最后还要将锁"),v("code",[t._v("释放")]),t._v("给其他程序。")]),t._v(" "),v("ul",[v("li",[t._v("公平锁：按照申请锁的顺序提供锁")]),t._v(" "),v("li",[t._v("非公平锁： 不按申请锁的顺序提供锁")]),t._v(" "),v("li",[t._v("独享锁：仅允许被一个线程所持有")]),t._v(" "),v("li",[t._v("共享锁：允许多个线程持有")]),t._v(" "),v("li",[t._v("乐观锁：常用于读场景，先操作后拿锁，不等待锁释放")]),t._v(" "),v("li",[t._v("悲观锁：常用于写场景，先拿锁后操作，等待锁释放后拿锁执行，行锁表锁都是用这个")]),t._v(" "),v("li",[t._v("粗粒度锁：通过一个锁，把执行的代码块都锁定")]),t._v(" "),v("li",[t._v("细粒度锁：和粗粒度锁相对")]),t._v(" "),v("li",[t._v("带超时限制特性的锁")])]),t._v(" "),v("h4",{attrs:{id:"信号量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#信号量"}},[t._v("#")]),t._v(" 信号量")]),t._v(" "),v("ul",[v("li",[t._v("计数信号量： 限定能够同时使用的资源数量。通过时间戳作为有序集合的分值的方式，统计获得锁的用户，移除超时限的用户，剩下拿到锁的用户。缺点是多个客户端时，时间较慢的客户端会偷走时间较快的客户端的信号量。")]),t._v(" "),v("li",[t._v("公平信号量： 通过自增的计数器作为有序集合的分值的方式")])]),t._v(" "),v("h4",{attrs:{id:"细粒度锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#细粒度锁"}},[t._v("#")]),t._v(" 细粒度锁")]),t._v(" "),v("p",[t._v("在拥有多个操作分区情况下，如果只有单一一个锁，会阻塞多个请求。为了支持更高并发，减少阻塞，需细化锁的设计")]),t._v(" "),v("p",[t._v("分级锁的设计：")]),t._v(" "),v("ul",[v("li",[t._v("Top锁")]),t._v(" "),v("li",[t._v("Child锁")])]),t._v(" "),v("p",[t._v("使用规则： 在操作开始前，必须先申请得到Top锁来准备获取Child锁，在获取得到Child锁之后，可以再释放Top锁。这里的Child锁，可以理解为就是每个分区锁。这里Top锁的目的是为了保证获取各个分区锁的原子性。")]),t._v(" "),v("h3",{attrs:{id:"任务队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#任务队列"}},[t._v("#")]),t._v(" 任务队列")]),t._v(" "),v("p",[t._v("通过有序集合，分值为任务执行时间，定时轮询队列，按分值升序排序，小于当前时间的立即执行。")]),t._v(" "),v("h2",{attrs:{id:"性能优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[t._v("#")]),t._v(" 性能优化")]),t._v(" "),v("h3",{attrs:{id:"事务-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务-2"}},[t._v("#")]),t._v(" 事务")]),t._v(" "),v("p",[t._v("一次向Redis发送多条指令")]),t._v(" "),v("h3",{attrs:{id:"压缩列表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#压缩列表"}},[t._v("#")]),t._v(" 压缩列表")]),t._v(" "),v("ul",[v("li",[t._v("让键名保持简短")]),t._v(" "),v("li",[t._v("使用短结构")])])])}),[],!1,null,null,null);v.default=d.exports}}]);