(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{505:function(a,t,v){"use strict";v.r(t);var _=v(19),s=Object(_.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"微服务架构设计模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#微服务架构设计模式"}},[a._v("#")]),a._v(" 微服务架构设计模式")]),a._v(" "),t("h2",{attrs:{id:"介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[a._v("#")]),a._v(" 介绍")]),a._v(" "),t("p",[a._v("一种具有更高可维护性、可测试性和可部署性的架构风格。微服务不是银弹： 它存在包括复杂性在内的诸多弊端。")]),a._v(" "),t("h2",{attrs:{id:"概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[a._v("#")]),a._v(" 概念")]),a._v(" "),t("h3",{attrs:{id:"软件架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#软件架构"}},[a._v("#")]),a._v(" 软件架构")]),a._v(" "),t("p",[a._v("是一种抽象的结构，它由软件的各个组成部分和这些部分之间的依赖关系构成。架构很重要的原因是它决定了应用程序的质量属性或能力。传统上，架构的目的是可拓展性、可靠性和安全性。")]),a._v(" "),t("h3",{attrs:{id:"视图模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#视图模型"}},[a._v("#")]),a._v(" 视图模型")]),a._v(" "),t("p",[a._v("软件架构的4+1视图模型：")]),a._v(" "),t("ul",[t("li",[a._v("逻辑视图： 开发人员创建的软件元素。eg: 类和包之间的关系，包括继承、关联和依赖")]),a._v(" "),t("li",[a._v("实现视图： 构建编译系统的输出。eg: 组件是由一个或多个模块组成的可执行或可部署单元")]),a._v(" "),t("li",[a._v("进程视图： 运行时的组件。 每个元素都是一个进程，进程之间的关系代表进程间通信")]),a._v(" "),t("li",[a._v("部署视图： 进程如何映射到机器。此视图中的元素由计算机和进程组成。机器之间的关系代表网络。该视图还描述了进程和机器之间的关系")]),a._v(" "),t("li",[a._v("场景： 将视图串联在一起。每个场景描述在一个的多个架构元素如何协作，以完成一个请求。")])]),a._v(" "),t("h3",{attrs:{id:"软件架构的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#软件架构的作用"}},[a._v("#")]),a._v(" 软件架构的作用")]),a._v(" "),t("p",[a._v("应用程序由两个层面的需求。")]),a._v(" "),t("ol",[t("li",[t("code",[a._v("功能性需求")]),a._v("： 决定一个应用程序做什么。通常包含在用例或者用户故事中")]),a._v(" "),t("li",[t("code",[a._v("非功能性需求")]),a._v("： 这类需求也成为"),t("code",[a._v("质量属性")]),a._v("需求，或者称为"),t("code",[a._v("能力")]),a._v("。这些非功能性需求决定一个应用程序在运行时的质量。 eg: 可拓展性、可靠性、可维护性、可测性、可部署性等。")])]),a._v(" "),t("h2",{attrs:{id:"分层式架构风格"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分层式架构风格"}},[a._v("#")]),a._v(" 分层式架构风格")]),a._v(" "),t("p",[a._v("将软件元素按“层”的方式组织，每层都有明确定义的职责。分层架构还限制了层之间的依赖关系，每一层只能依赖于紧邻其下方的层或其下面的任何层。")]),a._v(" "),t("h3",{attrs:{id:"三层架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三层架构"}},[a._v("#")]),a._v(" 三层架构")]),a._v(" "),t("p",[a._v("应用于逻辑视图分离的分层架构，它将应用程序的类组织到以下层中：")]),a._v(" "),t("ul",[t("li",[a._v("表现层： 包含实现用户界面或外部API的代码")]),a._v(" "),t("li",[a._v("业务逻辑层： 包含业务逻辑")]),a._v(" "),t("li",[a._v("数据持久化层： 实现与数据库交互的逻辑")])]),a._v(" "),t("h4",{attrs:{id:"弊端"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#弊端"}},[a._v("#")]),a._v(" 弊端")]),a._v(" "),t("ul",[t("li",[a._v("单个表现层： 无法展现应用程序可能不仅仅由单个系统调用的事实")]),a._v(" "),t("li",[a._v("单一数据持久化层： 它无法展现应用程序可能与多个数据库进行交互的事实")]),a._v(" "),t("li",[a._v("将业务逻辑层定义为依赖于数据持久化层： 理论上，这样的依赖性会妨碍你在没有数据库的情况下测试业务逻辑")])]),a._v(" "),t("h3",{attrs:{id:"六边形架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#六边形架构"}},[a._v("#")]),a._v(" 六边形架构")]),a._v(" "),t("h2",{attrs:{id:"服务的拆分策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#服务的拆分策略"}},[a._v("#")]),a._v(" 服务的拆分策略")])])}),[],!1,null,null,null);t.default=s.exports}}]);