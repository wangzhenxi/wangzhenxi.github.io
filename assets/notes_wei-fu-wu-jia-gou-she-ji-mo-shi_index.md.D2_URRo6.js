import{_ as e,o as i,c as l,af as o}from"./chunks/framework.R7EdO4cN.js";const f=JSON.parse('{"title":"微服务架构设计模式","description":"","frontmatter":{"hide":true,"title":"微服务架构设计模式"},"headers":[],"relativePath":"notes/wei-fu-wu-jia-gou-she-ji-mo-shi/index.md","filePath":"notes/wei-fu-wu-jia-gou-she-ji-mo-shi/index.md"}'),t={name:"notes/wei-fu-wu-jia-gou-she-ji-mo-shi/index.md"};function r(h,a,d,n,s,c){return i(),l("div",null,[...a[0]||(a[0]=[o('<h1 id="微服务架构设计模式" tabindex="-1">微服务架构设计模式 <a class="header-anchor" href="#微服务架构设计模式" aria-label="Permalink to &quot;微服务架构设计模式&quot;">​</a></h1><h2 id="介绍" tabindex="-1">介绍 <a class="header-anchor" href="#介绍" aria-label="Permalink to &quot;介绍&quot;">​</a></h2><p>一种具有更高可维护性、可测试性和可部署性的架构风格。微服务不是银弹： 它存在包括复杂性在内的诸多弊端。</p><h2 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h2><h3 id="软件架构" tabindex="-1">软件架构 <a class="header-anchor" href="#软件架构" aria-label="Permalink to &quot;软件架构&quot;">​</a></h3><p>是一种抽象的结构，它由软件的各个组成部分和这些部分之间的依赖关系构成。架构很重要的原因是它决定了应用程序的质量属性或能力。传统上，架构的目的是可拓展性、可靠性和安全性。</p><h3 id="视图模型" tabindex="-1">视图模型 <a class="header-anchor" href="#视图模型" aria-label="Permalink to &quot;视图模型&quot;">​</a></h3><p>软件架构的4+1视图模型：</p><ul><li>逻辑视图： 开发人员创建的软件元素。eg: 类和包之间的关系，包括继承、关联和依赖</li><li>实现视图： 构建编译系统的输出。eg: 组件是由一个或多个模块组成的可执行或可部署单元</li><li>进程视图： 运行时的组件。 每个元素都是一个进程，进程之间的关系代表进程间通信</li><li>部署视图： 进程如何映射到机器。此视图中的元素由计算机和进程组成。机器之间的关系代表网络。该视图还描述了进程和机器之间的关系</li><li>场景： 将视图串联在一起。每个场景描述在一个的多个架构元素如何协作，以完成一个请求。</li></ul><h3 id="软件架构的作用" tabindex="-1">软件架构的作用 <a class="header-anchor" href="#软件架构的作用" aria-label="Permalink to &quot;软件架构的作用&quot;">​</a></h3><p>应用程序由两个层面的需求。</p><ol><li><code>功能性需求</code>： 决定一个应用程序做什么。通常包含在用例或者用户故事中</li><li><code>非功能性需求</code>： 这类需求也成为<code>质量属性</code>需求，或者称为<code>能力</code>。这些非功能性需求决定一个应用程序在运行时的质量。 eg: 可拓展性、可靠性、可维护性、可测性、可部署性等。</li></ol><h2 id="分层式架构风格" tabindex="-1">分层式架构风格 <a class="header-anchor" href="#分层式架构风格" aria-label="Permalink to &quot;分层式架构风格&quot;">​</a></h2><p>将软件元素按“层”的方式组织，每层都有明确定义的职责。分层架构还限制了层之间的依赖关系，每一层只能依赖于紧邻其下方的层或其下面的任何层。</p><h3 id="三层架构" tabindex="-1">三层架构 <a class="header-anchor" href="#三层架构" aria-label="Permalink to &quot;三层架构&quot;">​</a></h3><p>应用于逻辑视图分离的分层架构，它将应用程序的类组织到以下层中：</p><ul><li>表现层： 包含实现用户界面或外部API的代码</li><li>业务逻辑层： 包含业务逻辑</li><li>数据持久化层： 实现与数据库交互的逻辑</li></ul><h4 id="弊端" tabindex="-1">弊端 <a class="header-anchor" href="#弊端" aria-label="Permalink to &quot;弊端&quot;">​</a></h4><ul><li>单个表现层： 无法展现应用程序可能不仅仅由单个系统调用的事实</li><li>单一数据持久化层： 它无法展现应用程序可能与多个数据库进行交互的事实</li><li>将业务逻辑层定义为依赖于数据持久化层： 理论上，这样的依赖性会妨碍你在没有数据库的情况下测试业务逻辑</li></ul><h3 id="六边形架构" tabindex="-1">六边形架构 <a class="header-anchor" href="#六边形架构" aria-label="Permalink to &quot;六边形架构&quot;">​</a></h3><h2 id="服务的拆分策略" tabindex="-1">服务的拆分策略 <a class="header-anchor" href="#服务的拆分策略" aria-label="Permalink to &quot;服务的拆分策略&quot;">​</a></h2>',21)])])}const m=e(t,[["render",r]]);export{f as __pageData,m as default};
