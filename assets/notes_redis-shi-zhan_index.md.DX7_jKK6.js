import{_ as d,o as e,c as a,ae as r}from"./chunks/framework.CLid5Cgc.js";const k=JSON.parse('{"title":"Redis实战","description":"","frontmatter":{"title":"Redis实战"},"headers":[],"relativePath":"notes/redis-shi-zhan/index.md","filePath":"notes/redis-shi-zhan/index.md"}'),o={name:"notes/redis-shi-zhan/index.md"};function i(l,t,c,h,n,s){return e(),a("div",null,[...t[0]||(t[0]=[r('<h1 id="redis实战" tabindex="-1">Redis实战 <a class="header-anchor" href="#redis实战" aria-label="Permalink to &quot;Redis实战&quot;">​</a></h1><h2 id="名词" tabindex="-1">名词 <a class="header-anchor" href="#名词" aria-label="Permalink to &quot;名词&quot;">​</a></h2><ul><li>ACID： atomicity原子性、consistency一致性、isolation隔离性、durability耐久性，一个数据库实现可靠的数据事务需满足的性质。</li></ul><h2 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h2><ul><li>速度快： 使用内存存储的非关系型数据库。</li><li>原子性： 当命令正在读取或修改数据的时候，其他客户端不能读取或修改相同的数据。</li></ul><h2 id="数据类型" tabindex="-1">数据类型 <a class="header-anchor" href="#数据类型" aria-label="Permalink to &quot;数据类型&quot;">​</a></h2><table tabindex="0"><thead><tr><th>结构类型</th><th>结构存储的值</th><th>场景</th></tr></thead><tbody><tr><td>STRING</td><td>字符串、浮点数、整数</td><td></td></tr><tr><td>LIST</td><td>一个链表</td><td></td></tr><tr><td>SET</td><td>无序去重的集合</td><td></td></tr><tr><td>HASH</td><td>包含键值对的无序散列表</td><td></td></tr><tr><td>ZSET</td><td>根据分值大小排序且去重的有序映射</td><td>排行榜(分值越小，排行靠前)</td></tr></tbody></table><h3 id="指令" tabindex="-1">指令 <a class="header-anchor" href="#指令" aria-label="Permalink to &quot;指令&quot;">​</a></h3><h4 id="setring-字符串" tabindex="-1">SETRING 字符串 <a class="header-anchor" href="#setring-字符串" aria-label="Permalink to &quot;SETRING 字符串&quot;">​</a></h4><ul><li>GET</li><li>SET</li><li>DEL</li></ul><table tabindex="0"><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td><code>APPEND key value</code></td><td>将值追加到字符串尾部</td></tr><tr><td><code>GETRANGE key value</code></td><td>将值追加到字符串尾部</td></tr></tbody></table><h4 id="list-列表" tabindex="-1">LIST 列表 <a class="header-anchor" href="#list-列表" aria-label="Permalink to &quot;LIST 列表&quot;">​</a></h4><p>redis使用双链表表示列表</p><ul><li>RPUSH</li><li>LPUSH</li><li>LRANGE</li><li>LINDEX 获取给定位置的元素</li></ul><h4 id="set-集合" tabindex="-1">SET 集合 <a class="header-anchor" href="#set-集合" aria-label="Permalink to &quot;SET 集合&quot;">​</a></h4><p>redis通过配置可设置集合使用整数集合表示的限制条件，超出限制则使用散列表表示。</p><table tabindex="0"><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td><code>SADD key item1 [item2 ...]</code></td><td>增加一个或多个元素</td></tr><tr><td><code>SMEMBERS key</code></td><td>返回集合包含的所有元素</td></tr><tr><td><code>SISMEMBER key item</code></td><td>是否在集合中</td></tr><tr><td><code>SREM key item</code></td><td>移除元素</td></tr><tr><td><code>SCARD key</code></td><td>返回集合包含元素数量</td></tr><tr><td><code>SRANDMEMBER key [count]</code></td><td>随机返回count个元素，整数不重复，负数会重复</td></tr><tr><td><code>SPOP key</code></td><td>随机移除一个元素</td></tr><tr><td><code>SMOVE source-key dest-key item</code></td><td>将item从source-key集合中移除，并移入dest-key的集合下</td></tr><tr><td><code>SDIFF key1 [key2 ...]</code></td><td>返回存在于key1，不存在于其他集合的元素(差集)</td></tr><tr><td><code>SDIFFSTORE dest-key key1 [key2 ...]</code></td><td>将存在于key1，不存在于其他集合的元素，存储到dest-key去(差集)</td></tr><tr><td><code>SINTER key1 [key2 ...]</code></td><td>返回同时存在于所有集合的元素(交集)</td></tr><tr><td><code>SINTERSTORE dest-key key1 [key2 ...]</code></td><td>返回同时存在于所有集合的元素,存储到dest-key去(交集)</td></tr><tr><td><code>SUNION key1 [key2 ...]</code></td><td>返回那些至少存在于一个集合中的元素(并集)</td></tr><tr><td><code>SUNIONSTORE dest-key key1 [key2 ...]</code></td><td>返回那些至少存在于一个集合中的元素,存储到dest-key去(并集)</td></tr></tbody></table><h4 id="hash-散列" tabindex="-1">HASH 散列 <a class="header-anchor" href="#hash-散列" aria-label="Permalink to &quot;HASH 散列&quot;">​</a></h4><p>redis使用散列表表示散列</p><table tabindex="0"><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td><code>HSET key field1 value1 [field2 value2]</code></td><td>为散列里面的一个或多个键设置值</td></tr><tr><td><code>HGET key field</code></td><td>从散列里获取键的值</td></tr><tr><td><code>HMGET key field1 [field2]</code></td><td>从散列里获取键的值</td></tr><tr><td><code>HDEL key field1 [field2]</code></td><td>移除散列一个或多个键值对</td></tr><tr><td><code>HLEN key</code></td><td>获取散列键值对数量</td></tr><tr><td><code>HEXISTS key filed</code></td><td>检查给定键是否存在于散列中</td></tr><tr><td><code>HKEYS key</code></td><td>获取散列包含的所有键</td></tr><tr><td><code>HVALS key</code></td><td>获取散列包含的所有值</td></tr><tr><td><code>HGETALL key</code></td><td>获取散列所有键值</td></tr><tr><td><code>HINCRBY key field increment</code></td><td>给散列指定键的值加上整数increment</td></tr><tr><td><code>HINCRBYFLOAT key filed increment</code></td><td>给散列指定键的值加上浮点数increment</td></tr></tbody></table><h4 id="zset-有序集合" tabindex="-1">ZSET 有序集合 <a class="header-anchor" href="#zset-有序集合" aria-label="Permalink to &quot;ZSET 有序集合&quot;">​</a></h4><p>redis通过散列表加上跳跃表表示有序集合</p><table tabindex="0"><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td><code>ZADD key score member [score2 member2 ...]</code></td><td>将带有一定分值的成员添加到有序集合</td></tr><tr><td><code>ZREM key member1 [member2 ...]</code></td><td>移除成员</td></tr><tr><td><code>ZCARD key</code></td><td>返回有序集合成员数量</td></tr><tr><td><code>ZINCRBY key increment member</code></td><td>将member成员的分值加上increment</td></tr><tr><td><code>ZCOUNT key min max</code></td><td>返回分值介于min和max之间的成员数量</td></tr><tr><td><code>ZSCORE key member</code></td><td>返回成员member的分值</td></tr><tr><td><code>ZRANK key member</code></td><td>分值升序排序，返回成员member在有序集合之中的排名</td></tr><tr><td><code>ZRANGE key start stop [WITHSCORES]</code></td><td>分值升序排序，返回排名介于start和stop之间的成员，如果给了WITHSCORES参数，则将成员分值一并返回</td></tr><tr><td><code>ZREVRANK key member</code></td><td>分值升序排序，返回成员member在有序集合之中的排名</td></tr><tr><td><code>ZREVRANGE key start stop [WITHSCORES]</code></td><td>分值降序排序，返回排名介于start和stop之间的成员，如果给了WITHSCORES参数，则将成员分值一并返回</td></tr><tr><td><code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code></td><td>分值升序排序，返回分值介于min和max之间的成员，如果给了WITHSCORES参数，则将成员分值一并返回</td></tr><tr><td><code>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</code></td><td>分值降序排序，返回分值介于max和min之间的成员，如果给了WITHSCORES参数，则将成员分值一并返回</td></tr><tr><td><code>ZREMRANGEBYSRANK key start stop</code></td><td>分值升序排序，移除排名介于start和stop之间的成员</td></tr><tr><td><code>ZREMRANGEBYSCORE key min max</code></td><td>分值升序排序，移除排名介于min和max之间的成员</td></tr><tr><td>`ZINTERSTORE dest-key key-count key1 [key2 ...] [WEIGHTS weight1 [weight2]] [AGGREGATE SUM</td><td>MIN</td></tr><tr><td>`ZUNIONSTORE dest-key key-count key1 [key2 ...] [WEIGHTS weight1 [weight2]] [AGGREGATE SUM</td><td>MIN</td></tr></tbody></table><h4 id="其他命令" tabindex="-1">其他命令 <a class="header-anchor" href="#其他命令" aria-label="Permalink to &quot;其他命令&quot;">​</a></h4><table tabindex="0"><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>`SORT key [BY pattern] [LIMIT offset count] [GET pattern] [ASC</td><td>DESC] [ALPHA] destination`</td></tr></tbody></table><h5 id="发布与订阅" tabindex="-1">发布与订阅 <a class="header-anchor" href="#发布与订阅" aria-label="Permalink to &quot;发布与订阅&quot;">​</a></h5><table tabindex="0"><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td><code>SUBSCRIBE channel [channel]</code></td><td>订阅给定一个或多个频道</td></tr><tr><td><code>UNSUBSCRIBE [channel... [channel2 ...]]</code></td><td>退订给定一个或多个频道，没有给定则退订所有频道</td></tr><tr><td><code>PUBLISH channel message</code></td><td>向给定频道发送消息</td></tr><tr><td><code>PSUBSCRIBE pattern1 [pattern2 ...]</code></td><td>订阅与给定模式匹配的所有频道</td></tr><tr><td><code>PUNSUBSCRIBE pattern1 [pattern2 ...]</code></td><td>退订给定模式匹配的所有坡；频道，没有给定则退订所有频道</td></tr></tbody></table><h5 id="事务" tabindex="-1">事务 <a class="header-anchor" href="#事务" aria-label="Permalink to &quot;事务&quot;">​</a></h5><table tabindex="0"><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td><code>MULTI</code></td><td>事务开始</td></tr><tr><td><code>EXEC</code></td><td>执行事务开始后的多个指令</td></tr></tbody></table><h5 id="过期" tabindex="-1">过期 <a class="header-anchor" href="#过期" aria-label="Permalink to &quot;过期&quot;">​</a></h5><table tabindex="0"><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td><code>PERSIST key</code></td><td>移除键的过期时间(s)</td></tr><tr><td><code>TTL key</code></td><td>查看键距离过期剩余时间(s)</td></tr><tr><td><code>EXPIRE key seconds</code></td><td>给定键在指定秒数后过期</td></tr><tr><td><code>EXPIREAT key timestamp</code></td><td>给定键在给定UNIX时间戳(s)后过期</td></tr><tr><td><code>PTTL key</code></td><td>查看键距离过期剩余时间(ms)</td></tr><tr><td><code>PEXPIRE key milliseconds</code></td><td>给定键在指定毫秒数后过期</td></tr><tr><td><code>PEXPIREAT key timestamp-milliseconds</code></td><td>给定键在给定UNIX时间戳(ms)后过期</td></tr></tbody></table><h2 id="数据持久化" tabindex="-1">数据持久化 <a class="header-anchor" href="#数据持久化" aria-label="Permalink to &quot;数据持久化&quot;">​</a></h2><h3 id="方法" tabindex="-1">方法 <a class="header-anchor" href="#方法" aria-label="Permalink to &quot;方法&quot;">​</a></h3><ul><li>快照: 把某一时刻所有数据写入硬盘</li><li>AOF: append-only file，在执行命令时，将被执行的命令写入硬盘</li></ul><h3 id="指令-1" tabindex="-1">指令 <a class="header-anchor" href="#指令-1" aria-label="Permalink to &quot;指令&quot;">​</a></h3><table tabindex="0"><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>BGSAVE</td><td>创建一个快照。通过fork一个子进程，负责将快照写入硬盘，而父进程继续处理命令。缺点： 速度慢，内存占用大</td></tr><tr><td>SAVE</td><td>创建一个快照。在快照创建完毕前不再响应任何其他指令 。缺点：无法正常执行其他指令</td></tr><tr><td>SHUTDOWN</td><td>执行SAVE后关闭服务器</td></tr><tr><td>BGREWRITEAOF</td><td>移除AOF文件中冗余命令来重写AOF文件，从而减小AOF文件体积，工作原理同<code>BGSAVE</code></td></tr><tr><td>INFO</td><td>查看服务器当前状态有关信息，如内存占用量、客户端连接数、上次快照后执行的命令数量等，其中<code>aof_pending_bio_fsync</code>为0时，表示服务器将所有数据已持久化到硬盘了</td></tr></tbody></table><h2 id="实践" tabindex="-1">实践 <a class="header-anchor" href="#实践" aria-label="Permalink to &quot;实践&quot;">​</a></h2><h3 id="分布式锁" tabindex="-1">分布式锁 <a class="header-anchor" href="#分布式锁" aria-label="Permalink to &quot;分布式锁&quot;">​</a></h3><p>用于解决能够被不同客户端多个进程访问的共享内存数据结构。在数据进行<code>加锁</code>时，程序需通过获取锁来对数据进行<code>排他性访问</code>的能力，才能对数据进行操作，最后还要将锁<code>释放</code>给其他程序。</p><ul><li>公平锁：按照申请锁的顺序提供锁</li><li>非公平锁： 不按申请锁的顺序提供锁</li><li>独享锁：仅允许被一个线程所持有</li><li>共享锁：允许多个线程持有</li><li>乐观锁：常用于读场景，先操作后拿锁，不等待锁释放</li><li>悲观锁：常用于写场景，先拿锁后操作，等待锁释放后拿锁执行，行锁表锁都是用这个</li><li>粗粒度锁：通过一个锁，把执行的代码块都锁定</li><li>细粒度锁：和粗粒度锁相对</li><li>带超时限制特性的锁</li></ul><h4 id="信号量" tabindex="-1">信号量 <a class="header-anchor" href="#信号量" aria-label="Permalink to &quot;信号量&quot;">​</a></h4><ul><li>计数信号量： 限定能够同时使用的资源数量。通过时间戳作为有序集合的分值的方式，统计获得锁的用户，移除超时限的用户，剩下拿到锁的用户。缺点是多个客户端时，时间较慢的客户端会偷走时间较快的客户端的信号量。</li><li>公平信号量： 通过自增的计数器作为有序集合的分值的方式</li></ul><h4 id="细粒度锁" tabindex="-1">细粒度锁 <a class="header-anchor" href="#细粒度锁" aria-label="Permalink to &quot;细粒度锁&quot;">​</a></h4><p>在拥有多个操作分区情况下，如果只有单一一个锁，会阻塞多个请求。为了支持更高并发，减少阻塞，需细化锁的设计</p><p>分级锁的设计：</p><ul><li>Top锁</li><li>Child锁</li></ul><p>使用规则： 在操作开始前，必须先申请得到Top锁来准备获取Child锁，在获取得到Child锁之后，可以再释放Top锁。这里的Child锁，可以理解为就是每个分区锁。这里Top锁的目的是为了保证获取各个分区锁的原子性。</p><h3 id="任务队列" tabindex="-1">任务队列 <a class="header-anchor" href="#任务队列" aria-label="Permalink to &quot;任务队列&quot;">​</a></h3><p>通过有序集合，分值为任务执行时间，定时轮询队列，按分值升序排序，小于当前时间的立即执行。</p><h2 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h2><h3 id="事务-1" tabindex="-1">事务 <a class="header-anchor" href="#事务-1" aria-label="Permalink to &quot;事务&quot;">​</a></h3><p>一次向Redis发送多条指令</p><h3 id="压缩列表" tabindex="-1">压缩列表 <a class="header-anchor" href="#压缩列表" aria-label="Permalink to &quot;压缩列表&quot;">​</a></h3><ul><li>让键名保持简短</li><li>使用短结构</li></ul>',54)])])}const y=d(o,[["render",i]]);export{k as __pageData,y as default};
